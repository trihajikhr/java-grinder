{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Main Page","text":"Java Practice &amp; Learning Log \u2615 <p>Repositori ini berisi seluruh latihan, eksperimen, dan catatan pribadi selama proses mempelajari bahasa pemrograman Java. Setiap latihan mencakup penjelasan konsep, penerapan kode, dan beberapa pratik. Semua progres disusun agar pembelajaran mudah ditelusuri kembali dimasa depan.</p> <p>Keterangan folder: - \ud83d\udee0\ufe0f Dev-lab, tempat file eksperimen dan file latihan Java disimpan. - \ud83d\udc1e Error-log, dokumentasi error selama proses latihan. Berisi beberapa materi tambahan tentang penyebab error dan solusi. - \ud83d\udcd1 Theory, folder tempat file materi dan konsep.</p> <p>Baca teori, lalu perbanyak praktek. Dari praktek, kamu belajar dari error dengan menemukan solusi dan membuka konsep dan pendekatan baru.</p> <p>Tips: Baca beberapa kode orang lain jika perlu</p> <p>halo kawan apa yang kamu lakukan, aku harap kita bisa bersahabata! enthalah</p>"},{"location":"Changelog/","title":"Java Crash Course","text":""},{"location":"navigation/","title":"Navigation","text":"<ul> <li>Home<ul> <li>Main Page</li> <li>Navigation</li> <li>Tag index</li> <li>How to Contribute</li> <li>Code of conduct</li> <li>Change log</li> </ul> </li> <li>Java Basic<ul> <li>Basic Syntax</li> <li>Lifecycle of a Program</li> <li>Data Types and Variables</li> <li>Variables and Scopes</li> <li>Type Casting</li> <li>Strings and Methods</li> <li>Math Operations</li> <li>Arrays</li> <li>Conditionals</li> <li>Loops</li> <li>Basics of OOPS</li> </ul> </li> <li>Exception Handling<ul> <li>Exception Handling in Java</li> <li>Kasus throws dan try catch</li> </ul> </li> </ul>"},{"location":"exception-handling/01-Exception-Handling-in-Java/","title":"Exception Handling in Java","text":"<p>Pada tutorial kali ini, kita akan belajar materi basic dari exception handling pada Java. Jadi, bersiaplah...</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#1-aturan-pertama","title":"1 | Aturan Pertama","text":""},{"location":"exception-handling/01-Exception-Handling-in-Java/#11-apa-itu-exception-handling","title":"1.1 | Apa itu Exception handling?","text":"<p>Untuk lebih memahami exception (pengecualian) dan exception handling (penanganan pengecualian), kita perlu membuat sebuah analogi nyata. Bayangkan kita melakukan sebuah pemesanan produk secara online, tetapi dijalan, rute yang biasa dilalui terdapat masalah . Perusahaan pengiriman yang baik akan mengatasi masalah ini dengan cara mencari atau mengalihkan rute pengiriman, sehingga produk akan tetap sampai tepat pada waktunya.</p> <p>Seperti halnya pada Java, kode bisa mengalami error ketika dieksekusi dan dijalankan. Exception handling yang baik harus bisa menangani error dan tetap membuat program berjalan dengan baik, memberikan penggunanya pengalaman yang memuaskan.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#12-kenapa-menggunakanya","title":"1.2 | Kenapa Menggunakanya?","text":"<p>Kita bisanya menulis kode pada lingkungan yang baik, file di sistem kita menyediakan semua yang kita cari dan butuhkan, dan jaringan mungkin selalu tersedia, dan JVM selalu memiliki cukup memory yang tersedia. Terkadang, kita menyebutnya dengan \"Happy path\", atau jalur yang menyenangkan.</p> <p>Tapi pada kode skala produksi, file sistem bisa mengalami corrupt, jaringan mungkin down, dan JVM kehabisan memory untuk bekerja. Kode kita harus dirancang untuk mampu menghadapi situasi dari \"Unhappy path\" atau jalan yang tidak menyenangkan ini.</p> <p>Kita harus bisa menangani kondisi seperti ini karena bisa mengganggu kelancaran dan alur kerja program, dan berdampak negatif pada kinerja aplikasi.</p> <pre><code>public static List&lt;Player&gt; getPlayers() throws IOException {\n    Path path = Paths.get(\"players.dat\");\n    List&lt;String&gt; players = Files.readAllLines(path);\n\n    return players.stream()\n      .map(Player::new)\n      .collect(Collectors.toList());\n}\n</code></pre> <p>Kode diatas tidak memiliki penangan <code>IOException</code>, dan langsung mengirimkannya ke call stack secara langsung. Pada lingkungan yang baik, kode tersebut mungkin bekerja.</p> <p>Tapi, apa jadinya jika selama produksi, file <code>player.dat</code> ternyata hilang?</p> <pre><code>Exception in thread \"main\" java.nio.file.NoSuchFileException: players.dat &lt;-- players.dat file doesn't exist\n    at sun.nio.fs.WindowsException.translateToIOException(Unknown Source)\n    at sun.nio.fs.WindowsException.rethrowAsIOException(Unknown Source)\n    // ... more stack trace\n    at java.nio.file.Files.readAllLines(Unknown Source)\n    at java.nio.file.Files.readAllLines(Unknown Source)\n    at Exceptions.getPlayers(Exceptions.java:12) &lt;-- Exception arises in getPlayers() method, on line 12\n    at Exceptions.main(Exceptions.java:19) &lt;-- getPlayers() is called by main(), on line 19\n</code></pre> <p>Tanpa exception handling, kode yang seharusnya bekerja dengan baik akan berhenti bekerja sama sekali. Kode yang bagus seharusnya bisa mengatasi masalah ini, kita sebagai penulis kode harus memiliki rencana jika terdapat sesuatu yang salah.</p> <p>Catat juga, satu keuntungan dari adanya exception handling, adalah kita bisa membuat stack trace. Dengan stack trace, kita bisa mengetahui bagian mana dari kode yang salah, tanpa perlu menggunakan debugger.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#2-hierarki-exception","title":"2 | Hierarki Exception","text":"<p>Pada dasarnya, exception hanyalah objek Java, dengan semua exception mewarisi dari <code>Throwable</code>:</p> <pre><code>              ---&gt; Throwable &lt;--- \n              |    (checked)     |\n              |                  |\n              |                  |\n      ---&gt; Exception           Error\n      |    (checked)        (unchecked)\n      |\nRuntimeException\n  (unchecked)\n</code></pre> <p>Ada tiga kategori utama dari kondisi exception:</p> <ol> <li>Checked exceptions</li> <li>Unchecked exceptions / Runtime exceptions</li> <li>Errors</li> </ol> <p>Runtime exception dan unchecked exception merujuk pada hal yang sama, sehingga seringkali bisa digunakan secara bergantian.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#21-checked-exception-pengecualian-terperiksa","title":"2.1 | Checked Exception (Pengecualian Terperiksa)","text":"<p>Checked exception adalah jenis pengecualian yang wajib ditangani oleh programmer, karena kompiler Java memeriksanya saat proses kompilasi. Artinya, kita harus menangani pengecualian tersebut secara langsung (menggunakan <code>try-catch</code>) atau menyatakannya akan dilempar ke luar metode dengan kata kunci <code>throws</code>.</p> <p>Menurut dokumentasi Oracle, checked exception digunakan ketika pemanggil metode masih mungkin melakukan pemulihan (recovery) dari kesalahan yang terjadi.</p> <p>Contoh checked exception yang umum adalah:  - <code>IOException</code> - <code>ServletException</code></p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#23-unchecked-exception-pengecualian-tidak-terperiksa","title":"2.3 | Unchecked Exception (Pengecualian Tidak Terperiksa)","text":"<p>Unchecked exception adalah jenis pengecualian yang tidak diwajibkan oleh kompiler Java untuk ditangani.</p> <p>Secara sederhana, jika kita membuat kelas exception yang mewarisi <code>RuntimeException</code>, maka exception tersebut termasuk unchecked; sedangkan jika tidak, maka ia tergolong checked.</p> <p>Meskipun tampak lebih praktis, dokumentasi Oracle menegaskan bahwa kedua jenis exception memiliki tujuan yang berbeda \u2014 checked digunakan untuk kesalahan situasional yang dapat dipulihkan, sedangkan unchecked digunakan untuk kesalahan akibat penggunaan kode yang salah (usage error).</p> <p>Beberapa contoh unchecked exception:</p> <ul> <li><code>NullPointerException</code></li> <li><code>IllegalArgumentException</code></li> <li><code>SecurityException</code></li> </ul>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#23-error-kesalahan-fatal","title":"2.3 | Error (Kesalahan Fatal)","text":"<p>Error mewakili kondisi serius dan umumnya tidak dapat dipulihkan, seperti ketidakcocokan pustaka, rekursi tak berujung, atau kebocoran memori.</p> <p>Meskipun kelas <code>Error</code> tidak mewarisi <code>RuntimeException</code>, ia tetap termasuk dalam kategori unchecked, artinya kompiler tidak memaksa kita untuk menanganinya.</p> <p>Dalam praktiknya, menangani, membuat instance, atau menurunkan kelas <code>Error</code> adalah hal yang tidak lazim. Biasanya, error dibiarkan mengalir hingga ke level tertinggi agar program berhenti, karena ini menandakan adanya masalah serius pada sistem.</p> <p>Contoh error yang umum:</p> <ul> <li><code>StackOverflowError</code></li> <li><code>OutOfMemoryError</code></li> </ul>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#3-handling-exceptions","title":"3 | Handling Exceptions","text":"<p>Dalam Java API, terdapat banyak bagian kode yang berpotensi menimbulkan kesalahan, dan beberapa di antaranya ditandai dengan exception, baik di deklarasi metode (signature) maupun di dokumentasi Javadoc, seperti berikut:</p> <pre><code>/**\n * @exception FileNotFoundException ...\n */\npublic Scanner(String fileName) throws FileNotFoundException {\n   // ...\n}\n</code></pre> <p>Seperti yang sudah dijelaskan sebelumnya, ketika kita memanggil metode yang \u201cberisiko\u201d semacam ini, kita wajib menangani checked exception, sedangkan unchecked exception boleh ditangani atau tidak \u2014 tergantung kebutuhan.</p> <p>Java menyediakan beberapa cara untuk menangani exception tersebut.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#31-throws","title":"3.1 | <code>throws</code>","text":"<p>Cara paling sederhana untuk \"menangani\" sebuah exception adalah dengan melemparkannya kembali menggunakan kata kunci <code>throws</code>:</p> <pre><code>public int getPlayerScore(String playerFile)\n  throws FileNotFoundException {\n\n    Scanner contents = new Scanner(new File(playerFile));\n    return Integer.parseInt(contents.nextLine());\n}\n</code></pre> <p>Karena <code>FileNotFoundException</code> merupakan checked exception, inilah cara paling sederhana untuk memenuhi aturan kompiler. Namun, akibatnya, setiap kode yang memanggil metode tersebut juga harus menangani exception itu!</p> <p>Sementara itu, <code>parseInt</code> dapat melempar <code>NumberFormatException</code>, tetapi karena jenisnya unchecked, kita tidak diwajibkan untuk menanganinya.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#32-try-catch","title":"3.2 | <code>try-catch</code>","text":"<p>Jika kita ingin menangani exception secara langsung, kita dapat menggunakan blok <code>try-catch</code>. Penanganannya bisa dilakukan dengan dua cara:</p> <ol> <li>Melempar kembali exception dalam bentuk lain:</li> </ol> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        Scanner contents = new Scanner(new File(playerFile));\n        return Integer.parseInt(contents.nextLine());\n    } catch (FileNotFoundException noFile) {\n        throw new IllegalArgumentException(\"File not found\");\n    }\n}\n</code></pre> <ol> <li>Melakukan langkah pemulihan (recovery):</li> </ol> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        Scanner contents = new Scanner(new File(playerFile));\n        return Integer.parseInt(contents.nextLine());\n    } catch (FileNotFoundException noFile) {\n        logger.warn(\"File not found, resetting score.\");\n        return 0;\n    }\n}\n</code></pre>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#33-finally","title":"3.3 | <code>finally</code>","text":"<p>Ada kalanya kita memiliki kode yang harus dijalankan terlepas dari apakah terjadi exception atau tidak, dan di sinilah kata kunci <code>finally</code> digunakan.</p> <p>Dalam contoh sebelumnya, sebenarnya ada bug tersembunyi: secara default, Java tidak otomatis mengembalikan file handle ke sistem operasi. Karena itu, baik file berhasil dibaca atau tidak, kita harus memastikan proses pembersihan (cleanup) dilakukan dengan benar.</p> <p>Contoh paling sederhana:</p> <pre><code>public int getPlayerScore(String playerFile)\n  throws FileNotFoundException {\n    Scanner contents = null;\n    try {\n        contents = new Scanner(new File(playerFile));\n        return Integer.parseInt(contents.nextLine());\n    } finally {\n        if (contents != null) {\n            contents.close();\n        }\n    }\n}\n</code></pre> <p>Pada contoh di atas, blok <code>finally</code> menunjukkan kode yang akan selalu dijalankan, apa pun yang terjadi saat mencoba membaca file. Bahkan jika <code>FileNotFoundException</code> dilempar ke luar metode, isi dari blok <code>finally</code> tetap akan dijalankan terlebih dahulu.</p> <p>Kita juga bisa menangani exception sekaligus memastikan sumber daya ditutup dengan aman:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    Scanner contents;\n    try {\n        contents = new Scanner(new File(playerFile));\n        return Integer.parseInt(contents.nextLine());\n    } catch (FileNotFoundException noFile) {\n        logger.warn(\"File not found, resetting score.\");\n        return 0; \n    } finally {\n        try {\n            if (contents != null) {\n                contents.close();\n            }\n        } catch (IOException io) {\n            logger.error(\"Couldn't close the reader!\", io);\n        }\n    }\n}\n</code></pre> <p>Karena metode <code>close()</code> juga termasuk \u201cberisiko\u201d, kita harus menangani exception yang mungkin muncul darinya.</p> <p>Meskipun terlihat rumit, setiap bagian dari kode ini memiliki peran penting untuk menangani setiap kemungkinan kesalahan dengan tepat.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#34-try-with-resources","title":"3.4 | <code>try</code>-with-resources","text":"<p>Sejak Java 7, penulisan kode seperti contoh sebelumnya bisa dibuat jauh lebih sederhana saat bekerja dengan objek yang mengimplementasikan <code>AutoCloseable</code>.</p> <p>Contohnya:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try (Scanner contents = new Scanner(new File(playerFile))) {\n        return Integer.parseInt(contents.nextLine());\n    } catch (FileNotFoundException e) {\n        logger.warn(\"File not found, resetting score.\");\n        return 0;\n    }\n}\n</code></pre> <p>Dengan menempatkan objek yang bersifat <code>AutoCloseable</code> di dalam deklarasi <code>try</code>, kita tidak perlu lagi menutup resource secara manual \u2014 Java akan otomatis menutupnya setelah blok <code>try</code> selesai dieksekusi, baik berhasil maupun gagal.</p> <p>Kita tetap bisa menambahkan blok <code>finally</code> jika masih ada proses pembersihan lain yang perlu dilakukan.</p> <p>Untuk pembahasan lebih lengkap, bisa melihat artikel khusus yang membahas tentang try-with-resources.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#35-multiple-catch-blocks","title":"3.5 | Multiple catch blocks","text":"<p>Kadang, sebuah blok kode bisa melempar lebih dari satu jenis exception, dan kita bisa menanganinya dengan beberapa blok <code>catch</code> yang berbeda:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try (Scanner contents = new Scanner(new File(playerFile))) {\n        return Integer.parseInt(contents.nextLine());\n    } catch (IOException e) {\n        logger.warn(\"Player file wouldn't load!\", e);\n        return 0;\n    } catch (NumberFormatException e) {\n        logger.warn(\"Player file was corrupted!\", e);\n        return 0;\n    }\n}\n</code></pre> <p>Beberapa blok <code>catch</code> memungkinkan kita menangani setiap exception secara terpisah sesuai kebutuhan.</p> <p>Perhatikan bahwa pada contoh di atas, <code>FileNotFoundException</code> tidak ditangani secara eksplisit, karena kelas tersebut merupakan turunan dari <code>IOException</code>. Dengan menangani <code>IOException</code>, Java secara otomatis menganggap semua subclass-nya juga sudah ditangani.</p> <p>Namun, jika kita ingin memperlakukan <code>FileNotFoundException</code> secara berbeda dari <code>IOException</code> yang lebih umum, kita bisa menulisnya seperti ini:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try (Scanner contents = new Scanner(new File(playerFile))) {\n        return Integer.parseInt(contents.nextLine());\n    } catch (FileNotFoundException e) {\n        logger.warn(\"Player file not found!\", e);\n        return 0;\n    } catch (IOException e) {\n        logger.warn(\"Player file wouldn't load!\", e);\n        return 0;\n    } catch (NumberFormatException e) {\n        logger.warn(\"Player file was corrupted!\", e);\n        return 0;\n    }\n}\n</code></pre> <p>Java memungkinkan kita menangani subclass exception secara terpisah, tetapi pastikan urutannya benar \u2014 exception yang lebih spesifik harus ditangani terlebih dahulu sebelum yang lebih umum.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#36-union-catch-blocks","title":"3.6 | Union <code>catch</code> blocks","text":"<p>Jika kita tahu bahwa beberapa exception akan ditangani dengan cara yang sama, sejak Java 7 kita bisa menggunakan satu blok <code>catch</code> untuk menangkap lebih dari satu jenis exception sekaligus:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try (Scanner contents = new Scanner(new File(playerFile))) {\n        return Integer.parseInt(contents.nextLine());\n    } catch (IOException | NumberFormatException e) {\n        logger.warn(\"Failed to load score!\", e);\n        return 0;\n    }\n}\n</code></pre> <p>Dengan sintaks seperti ini, Java akan menangkap salah satu dari exception yang disebutkan di dalam tanda pemisah <code>|</code>, lalu menanganinya menggunakan blok kode yang sama.</p> <p>Fitur ini membantu membuat kode lebih ringkas dan mudah dibaca ketika penanganan untuk beberapa jenis exception identik.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#4-throwing-exceptions","title":"4 | Throwing Exceptions","text":"<p>Jika kita tidak ingin menangani exception secara langsung, atau ingin membuat exception sendiri agar bisa ditangani oleh kode lain, maka kita perlu memahami penggunaan kata kunci <code>throw</code>.</p> <p>Misalnya, kita membuat sendiri sebuah checked exception bernama <code>TimeoutException</code>:</p> <pre><code>public class TimeoutException extends Exception {\n    public TimeoutException(String message) {\n        super(message);\n    }\n}\n</code></pre> <p>Lalu kita memiliki sebuah metode yang mungkin membutuhkan waktu lama untuk diselesaikan:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) {\n    // ... potentially long operation\n}\n</code></pre>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#41-throwing-a-checked-exception","title":"4.1 | Throwing a checked exception","text":"<p>Sama seperti pernyataan <code>return</code>, kita bisa menggunakan <code>throw</code> kapan saja di dalam metode.</p> <p>Biasanya, kita melempar exception untuk menandakan bahwa terjadi kesalahan atau kondisi yang tidak normal:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) throws TimeoutException {\n    while (!tooLong) {\n        // ... potentially long operation\n    }\n    throw new TimeoutException(\"This operation took too long\");\n}\n</code></pre> <p>Karena <code>TimeoutException</code> merupakan checked exception, kita juga harus menambahkan kata kunci <code>throws</code> pada deklarasi metode agar pemanggil metode mengetahui bahwa exception tersebut perlu ditangani.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#42-throwing-an-unchecked-exception","title":"4.2 | Throwing an unchecked exception","text":"<p>Jika kita ingin melakukan sesuatu seperti memvalidasi input, kita bisa menggunakan unchecked exception:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) throws TimeoutException {\n    if (!isFilenameValid(playersFile)) {\n        throw new IllegalArgumentException(\"Filename isn't valid!\");\n    }\n\n    // ...\n}\n</code></pre> <p>Karena <code>IllegalArgumentException</code> termasuk unchecked exception, kita tidak wajib menandai metode dengan <code>throws</code>, meskipun tetap boleh dilakukan jika ingin.</p> <p>Beberapa developer tetap menuliskannya sebagai bentuk dokumentasi agar lebih jelas bahwa metode tersebut dapat melempar exception tertentu.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#44-wrapping-and-rethrowing","title":"4.4 | Wrapping and rethrowing","text":"<p>Kita juga bisa memilih untuk melempar kembali exception yang sudah kita tangkap:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) \n  throws IOException {\n    try { \n        // ...\n    } catch (IOException io) {      \n        throw io;\n    }\n}\n</code></pre> <p>Atau, kita bisa membungkusnya dalam exception baru sebelum melemparkannya kembali:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) \n  throws PlayerLoadException {\n    try { \n        // ...\n    } catch (IOException io) {      \n        throw new PlayerLoadException(io);\n    }\n}\n</code></pre> <p>Pendekatan ini berguna ketika kita ingin menyatukan berbagai jenis exception menjadi satu tipe yang lebih umum, sehingga penanganannya menjadi lebih sederhana di level yang lebih tinggi.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#45-rethrowing-throwable-atau-exception","title":"4.5 | Rethrowing Throwable atau Exception","text":"<p>Sekarang masuk ke kasus khusus.</p> <p>Jika di dalam suatu blok kode hanya ada kemungkinan munculnya unchecked exception, maka kita bisa menangkap dan melempar kembali (<code>rethrow</code>) <code>Throwable</code> atau <code>Exception</code> tanpa perlu menambahkannya ke deklarasi metode dengan <code>throws</code>:</p> <pre><code>public List&lt;Player&gt; loadAllPlayers(String playersFile) {\n    try {\n        throw new NullPointerException();\n    } catch (Throwable t) {\n        throw t;\n    }\n}\n</code></pre> <p>Meskipun tampak sederhana, kode di atas tidak dapat melempar checked exception, sehingga walaupun kita menulis <code>throw t</code>, kompiler tidak mengharuskan adanya klausa <code>throws</code> pada deklarasi metode.</p> <p>Teknik ini sering digunakan dalam proxy class atau metode dinamis, di mana kita perlu menangani dan melempar ulang berbagai jenis exception tanpa mendefinisikan semuanya satu per satu.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#45-inheritance","title":"4.5 | Inheritance","text":"<p>Ketika kita menandai suatu metode dengan kata kunci <code>throws</code>, hal itu akan memengaruhi bagaimana subclass boleh melakukan override terhadap metode tersebut.</p> <p>Jika metode di kelas induk melempar checked exception:</p> <pre><code>public class Exceptions {\n    public List&lt;Player&gt; loadAllPlayers(String playersFile) \n      throws TimeoutException {\n        // ...\n    }\n}\n</code></pre> <p>Maka subclass masih boleh membuat versi override dengan signature yang lebih aman (tidak melempar checked exception apa pun):</p> <pre><code>public class FewerExceptions extends Exceptions {   \n    @Override\n    public List&lt;Player&gt; loadAllPlayers(String playersFile) {\n        // overridden\n    }\n}\n</code></pre> <p>Namun subclass tidak boleh membuat versi override yang lebih berisiko, yaitu yang menambahkan checked exception baru:</p> <pre><code>public class MoreExceptions extends Exceptions {        \n    @Override\n    public List&lt;Player&gt; loadAllPlayers(String playersFile) throws MyCheckedException {\n        // overridden\n    }\n}\n</code></pre> <p>Alasannya adalah karena kontrak metode ditentukan pada waktu kompilasi berdasarkan tipe referensi, bukan tipe objek sebenarnya.</p> <p>Contohnya:</p> <pre><code>Exceptions exceptions = new MoreExceptions();\nexceptions.loadAllPlayers(\"file\");\n</code></pre> <p>Kompiler hanya akan mengharuskan kita menangani <code>TimeoutException</code>, padahal implementasi di subclass <code>MoreExceptions</code> justru melempar exception lain (<code>MyCheckedException</code>).</p> <p>Kesimpulannya: subclass boleh melempar lebih sedikit checked exception daripada superclass-nya, tapi tidak boleh lebih banyak.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#5-anti-patterns","title":"5 | Anti-Patterns","text":""},{"location":"exception-handling/01-Exception-Handling-in-Java/#51-swallowing-exceptions","title":"5.1 | Swallowing exceptions","text":"<p>Ada satu cara lain untuk membuat kode kita tetap lolos dari pemeriksaan kompiler, yaitu dengan menangkap dan mengabaikan exception sepenuhnya:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (Exception e) {} // &lt;== catch and swallow\n    return 0;\n}\n</code></pre> <p>Teknik ini disebut swallowing exception \u2014 artinya kita menangkap exception tapi tidak melakukan apa pun terhadapnya. Biasanya ini bukan praktik yang baik, karena masalahnya tidak diselesaikan, dan kode lain pun tidak bisa tahu bahwa ada kesalahan yang terjadi.</p> <p>Ada kalanya memang kita tahu bahwa exception tersebut tidak mungkin terjadi, misalnya karena kondisi yang sudah terjamin oleh logika program. Dalam kasus seperti itu, sebaiknya tetap beri komentar yang menjelaskan bahwa exception tersebut sengaja diabaikan:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (IOException e) {\n        // this will never happen\n    }\n}\n</code></pre> <p>Cara lain untuk \u201cmenelan\u201d exception adalah dengan hanya mencetaknya ke error stream:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return 0;\n}\n</code></pre> <p>Pendekatan ini sedikit lebih baik, karena setidaknya kita menulis pesan kesalahan untuk diagnosis di kemudian hari. Namun, cara yang lebih disarankan adalah dengan menggunakan logger:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (IOException e) {\n        logger.error(\"Couldn't load the score\", e);\n        return 0;\n    }\n}\n</code></pre> <p>Menangani exception dengan cara ini memang praktis, tapi kita perlu memastikan bahwa tidak ada informasi penting yang hilang, terutama jika pemanggil metode membutuhkan informasi itu untuk memperbaiki masalah.</p> <p>Kita juga bisa tanpa sengaja menelan exception dengan tidak menyertakannya sebagai penyebab ketika melempar exception baru:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (IOException e) {\n        throw new PlayerScoreException();\n    }\n}\n</code></pre> <p>Sekilas terlihat benar, karena kita melempar exception baru untuk memberi tahu bahwa ada kesalahan. Namun, kita kehilangan konteks asli (<code>IOException</code>) yang bisa membantu melacak akar masalahnya.</p> <p>Solusi yang benar adalah menyertakan exception asli sebagai penyebab:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (IOException e) {\n        throw new PlayerScoreException(e);\n    }\n}\n</code></pre> <p>Perbedaan kecil ini sangat penting \u2014 dengan menyertakan <code>IOException</code> sebagai penyebab, kita tetap mempertahankan jejak asal kesalahan sehingga lebih mudah untuk melakukan debug atau logging di kemudian hari.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#52-using-return-in-a-finally-block","title":"5.2 | Using return in a finally block","text":"<p>Cara lain yang tanpa sadar bisa menelan exception adalah dengan menggunakan <code>return</code> di dalam blok <code>finally</code>. Ini berbahaya karena ketika <code>finally</code> mengembalikan nilai secara tiba-tiba, JVM akan mengabaikan exception yang dilempar dari blok <code>try</code>.</p> <p>Contoh:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    int score = 0;\n    try {\n        throw new IOException();\n    } finally {\n        return score; // &lt;== IOException diabaikan\n    }\n}\n</code></pre> <p>Dalam kasus di atas, <code>IOException</code> tidak akan pernah terlihat oleh pemanggil metode, karena perintah <code>return</code> di dalam <code>finally</code> menimpa aliran eksekusi sebelumnya.</p> <p>Menurut Java Language Specification:</p> <p>Jika eksekusi blok <code>try</code> berakhir secara tiba-tiba karena suatu alasan R (misalnya karena exception), maka blok <code>finally</code> akan dijalankan terlebih dahulu.</p> <ul> <li>Jika blok <code>finally</code> berakhir secara normal, maka eksekusi <code>try</code> juga berakhir secara tiba-tiba karena alasan R.</li> <li>Namun, jika blok <code>finally</code> juga berakhir secara tiba-tiba karena alasan lain S (misalnya <code>return</code>, <code>throw</code>, atau <code>break</code>), maka alasan R akan dibuang, dan <code>try</code> akan berakhir karena alasan S.</li> </ul> <p>Artinya: jika kamu melakukan <code>return</code>, <code>throw</code> baru, atau keluar paksa dari <code>finally</code>, maka exception yang seharusnya muncul akan hilang total. Itu sebabnya, menempatkan <code>return</code> di dalam <code>finally</code> adalah praktik yang sebaiknya dihindari sepenuhnya.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#53-menggunakan-throw-di-dalam-finally-block","title":"5.3 | Menggunakan <code>throw</code> di dalam <code>finally</code> block","text":"<p>Mirip seperti penggunaan <code>return</code> di dalam blok <code>finally</code>, melempar exception (<code>throw</code>) di sana juga menggantikan exception sebelumnya yang mungkin muncul dari blok <code>try</code> atau <code>catch</code>.</p> <p>Akibatnya, exception asli yang seharusnya muncul akan hilang, dan yang tersisa hanya exception dari blok <code>finally</code>.</p> <p>Contoh:</p> <pre><code>public int getPlayerScore(String playerFile) {\n    try {\n        // ...\n    } catch (IOException io) {\n        throw new IllegalStateException(io); // &lt;== tertimpa oleh finally\n    } finally {\n        throw new OtherException();\n    }\n}\n</code></pre> <p>Pada kode di atas, <code>IllegalStateException</code> yang dilempar dari blok <code>catch</code> akan terhapus, karena blok <code>finally</code> juga melempar <code>OtherException</code>. Akhirnya, hanya <code>Other_exception_</code> yang terlihat keluar dari metode ini.</p> <p>Kesimpulannya: Jangan pernah melempar exception baru dari dalam <code>finally</code> kecuali benar-benar yakin. Jika perlu menangani kondisi khusus di <code>finally</code>, sebaiknya lakukan dengan hati-hati\u2014misalnya log error atau bersihkan sumber daya\u2014tanpa mengacaukan exception utama yang sedang diproses.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#54-menggunakan-throw-sebagai-goto","title":"5.4 | Menggunakan <code>throw</code> sebagai <code>goto</code>","text":"<p>Beberapa orang tergoda untuk menggunakan <code>throw</code> seolah-olah itu adalah pernyataan <code>goto</code>:</p> <pre><code>public void doSomething() {\n    try {\n        // sekumpulan kode pertama\n        throw new MyException();\n        // sekumpulan kode kedua\n    } catch (MyException e) {\n        // sekumpulan kode ketiga\n    }       \n}\n</code></pre> <p>Kode semacam ini aneh, karena <code>throw</code> di sini digunakan untuk mengatur alur program, bukan untuk menangani kesalahan.</p> <p>Pendekatan seperti ini membuat logika program jadi membingungkan, sulit diikuti, dan melanggar prinsip dasar dari pengecualian (exception) yang seharusnya hanya digunakan untuk menangani kondisi tak terduga, bukan untuk lompat-lompat antar bagian kode seperti <code>goto</code>.</p> <p>Kalau memang tujuannya hanya mengatur urutan eksekusi, gunakan kontrol alur normal seperti <code>if</code>, <code>return</code>, atau <code>break</code>, bukan <code>throw</code>.</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#6-common-exceptions-and-errors","title":"6 | Common Exceptions and Errors","text":"<p>Berikut beberapa pengecualian (exception) dan error umum yang sering ditemui dalam Java:</p>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#61-checked-exceptions","title":"6.1 | Checked Exceptions**","text":"<ul> <li>IOException \u2013 Pengecualian ini biasanya menunjukkan bahwa terjadi kegagalan pada jaringan, sistem berkas (filesystem), atau database.</li> </ul>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#62-runtime-exceptions","title":"6.2 | Runtime Exceptions","text":"<ul> <li> <p>ArrayIndexOutOfBoundsException \u2013 Terjadi ketika kita mencoba mengakses indeks array yang tidak ada, misalnya mencoba mengambil elemen indeks ke-5 dari array yang panjangnya hanya 3.</p> </li> <li> <p>ClassCastException \u2013 Terjadi ketika kita mencoba melakukan konversi (cast) yang tidak sah, misalnya mengubah <code>String</code> menjadi <code>List</code>. Biasanya bisa dihindari dengan melakukan pemeriksaan <code>instanceof</code> sebelum melakukan casting.</p> </li> <li> <p>IllegalArgumentException \u2013 Cara umum untuk menyatakan bahwa salah satu parameter yang diberikan ke metode atau konstruktor tidak valid.</p> </li> <li> <p>IllegalStateException \u2013 Cara umum untuk menyatakan bahwa kondisi internal (seperti status objek) tidak valid.</p> </li> <li> <p>NullPointerException \u2013 Terjadi ketika kita mencoba mengakses atau menggunakan objek yang bernilai <code>null</code>. Biasanya bisa dihindari dengan pemeriksaan <code>null</code> terlebih dahulu atau dengan menggunakan <code>Optional</code>.</p> </li> <li> <p>NumberFormatException \u2013 Terjadi ketika kita mencoba mengonversi <code>String</code> menjadi angka, tetapi <code>String</code> tersebut mengandung karakter yang tidak valid, misalnya mencoba mengubah <code>\"5f3\"</code> menjadi angka.</p> </li> </ul>"},{"location":"exception-handling/01-Exception-Handling-in-Java/#63-errors","title":"6.3 | Errors","text":"<ul> <li> <p>StackOverflowError \u2013 Terjadi ketika tumpukan (stack) terlalu besar. Kadang muncul pada aplikasi yang sangat besar, namun paling sering disebabkan oleh rekursi tanpa batas.</p> </li> <li> <p>NoClassDefFoundError \u2013 Terjadi ketika sebuah kelas gagal dimuat, biasanya karena tidak ada di classpath atau gagal saat inisialisasi statis.</p> </li> <li> <p>OutOfMemoryError \u2013 Terjadi ketika JVM kehabisan memori untuk membuat objek baru. Kadang disebabkan oleh kebocoran memori (memory leak).</p> </li> </ul>"},{"location":"exception-handling/02-Kasus-throws-dan-try-catch/","title":"Penggunaan throws","text":"<p>Kata kunci <code>throws</code> digunakan pada saat deklarasi method, untuk memberi tahu Java dan juga programmer lain bahwa:</p> <p>\"Hei, method ini bisa melempar error jenis X, tolong kamu yang manggil siap-siap tangkap ya.\"</p> <p>Biasanya penggunaan <code>throws</code> memiliki struktur umum seperti ini:</p> <pre><code>void namaMethod() throws JenisException {\n    // kode yang bisa bikin error\n}\n</code></pre>"},{"location":"exception-handling/02-Kasus-throws-dan-try-catch/#1-kasus-1-throws-basic","title":"1 | Kasus 1 - <code>throws</code> Basic","text":"<p>Misal aku memiliki kode Java, berikut adalah isi dari <code>Main.java</code>:</p> <pre><code>package exception;\n\npublic class Main {\n    public static void main(String[] args) {\n        Handler hand = new Handler();\n\n        hand.tambah();\n    }\n}\n</code></pre> <p>Dan ini adalah isi dari <code>Handler.java</code>:</p> <p><pre><code>package exception;\n\nimport java.util.Scanner;\n\npublic class Handler {\n    Scanner scan = new Scanner(System.in);\n\n    int tambah() {\n       int a = scan.nextInt();\n       int b = scan.nextInt();\n       return a + b;\n    }\n}\n</code></pre> Jika inputan yang diberikan keduanya adalah angka, maka program akan berjalan tanpa error. Tapi jika kita memasukan huruf atau karakter apapun yang bukan angka ketika program berjalan, maka akan muncul error seperti ini:</p> <pre><code>Exception in thread \"main\" java.util.InputMismatchException\n    at java.base/java.util.Scanner.throwFor(Scanner.java:964)\n    at java.base/java.util.Scanner.next(Scanner.java:1619)\n    at java.base/java.util.Scanner.nextInt(Scanner.java:2284)\n    at java.base/java.util.Scanner.nextInt(Scanner.java:2238)\n    at exception.Handler.tambah(Handler.java:9)\n    at exception.Main.main(Main.java:7)\n\nProcess finished with exit code 1\n</code></pre> <p>Terdapat kesalahan inputan, dimana tipe data integer justru menerima karakter selain angka, sehingga program berhenti karena error. </p> <p>Sekarang mari kita aplikasikan penggunaan <code>throws</code> untuk menghandle kasus ini. Sekarang, rubah kode program di file <code>Handler.java</code> menjadi seperti ini:</p> <pre><code>package exception;\n\nimport java.util.Scanner;\nimport java.util.InputMismatchException;\n\npublic class Handler {\n    Scanner scan = new Scanner(System.in);\n\n    int coba() throws InputMismatchException {\n        System.out.println(\"Masukkan dua angka: \");\n        int a = scan.nextInt();\n        int b = scan.nextInt();\n        return a + b;\n    }\n\n    void tambah() {\n        int ans;\n        try {\n            ans = coba();\n            System.out.println(\"Hasil: \" + ans);\n        } catch (InputMismatchException e) {\n            System.out.println(\"Error: Input tidak valid, hanya angka yang diperbolehkan.\");\n        }\n    }\n}\n</code></pre> <p>Kita membuat fungsi <code>tambah()</code> untuk melakukan pemanggilan secara aman pada fungsi <code>coba()</code>. Ketika fungsi <code>coba()</code> dideklarasikan dengan tambahan <code>throws</code>, maka fungsi tersebut menjadi memiliki kemampuan untuk bisa melempar exception atau error yang dialami pada fungsi tersebut, pada kasus ini yaitu <code>InputMismatchException</code>. Ketika hal ini terjadi, maka harus ada penangkapnya, sesuatu yang akan menangkap exceptions dari fungsi tersebut adalah <code>try-catch</code>.</p> <p>Oleh karena itu, fungsi <code>tambah()</code> harus memanggil fungsi <code>coba()</code> didalam blok <code>try</code>. Ketika program berjalan dengan baik, yaitu inputan sesuai, maka output berikut yang akan ditampilkan:</p> <pre><code>Masukkan dua angka:\n9\n10\nHasil: 19\n</code></pre> <p>Tetapi ketika inputan yang dimasukan tidak sesuai, maka fungsi <code>coba()</code> akan melemparkan  exception tersebut, dan blok <code>catch</code> akan menangkapnya. Ketika blok <code>catch</code> yang bekerja, maka output yang dihasilkan akan berbeda, yaitu seperti ini:</p> <pre><code>Masukkan dua angka:\n8\np\nError: Input tidak valid, hanya angka yang diperbolehkan.\n</code></pre>"},{"location":"exception-handling/02-Kasus-throws-dan-try-catch/#2-kasus-2-custom-exceptions","title":"2 | Kasus 2 - Custom Exceptions","text":"<p>Sekarang, selain fungsi tambah bisa mengatasi inputan yang tidak sesuai, sekarang kita akan merancang agar fungsi tersebut juga bisa mengatasi ketika inputan melebihi batas tertentu dengan cara yang lebih elegan, misal ketika inputan yang dimasukan adalah tidak boleh melebihi <code>1000000</code>.</p> <p>Pada kasus ini, perlu diketahui bahwa Java tidak memiliki exception untuk kasus seperti ini. Sehingga yang akan kita lakukan adalah dengan membuat <code>custom exception</code> sendiri.</p> <p>Berikut adalah perubahan file <code>Handler.java</code>:</p> <pre><code>package exception;\n\nimport java.util.Scanner;\nimport java.util.InputMismatchException;\n\npublic class Handler {\n    Scanner scan = new Scanner(System.in);\n\n    int coba() throws InputMismatchException, AngkaKelewatBatas {\n        System.out.println(\"Masukkan dua angka: \");\n        int a = scan.nextInt();\n\n        if(a &gt; 1_000_000){\n            throw new AngkaKelewatBatas(\"Angka melebihi batas!\");\n        }\n\n        int b = scan.nextInt();\n\n        if(b &gt; 1_000_000){\n            throw new AngkaKelewatBatas(\"Angka melebihi batas!\");\n        }\n\n        return a + b;\n    }\n\n    void tambah() {\n        int ans;\n        try {\n            ans = coba();\n            System.out.println(\"Hasil: \" + ans);\n        } catch (InputMismatchException e) {\n            System.out.println(\"Error: Input tidak valid, hanya angka yang diperbolehkan.\");\n        } catch (AngkaKelewatBatas e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}\n\nclass AngkaKelewatBatas extends Exception {\n    public AngkaKelewatBatas(String msg) {\n        super(msg);\n    }\n}\n</code></pre> <p>Apa yang kita lakukan? Kita membuat custom exceptions kita sendiri dengan membuat class dengan nama <code>AngkaKelewatBatas()</code>. Class ini akan kita set sebagai sub-class dari class <code>Exception</code>,  yang sudah ada di Java. Dengan menjadikannya subclass dari <code>Exception</code>, berarti <code>AngkaKelewatBatas</code> termasuk ke dalam kategori checked exception yang harus ditangani menggunakan <code>try-catch</code> atau dideklarasikan dengan <code>throws</code>.</p> <p>Class tersebut memiliki constructor yang menerima pesan dalam bentuk String (<code>msg</code>) dan meneruskanya ke constructor milik superclass <code>Exception</code> agar pesan tersebut bisa diakses melalui <code>getMessage()</code>.</p> <p>Pada fungsi <code>coba()</code>, kita menambahkan dua exception. Jadi jika kamu memiliki pertanyaan \"Apakah mungkin untuk suatu fungsi memiliki lebih dari satu exception\", maka disini jawabanya adalah bisa. Bisa juga ditaruh oleh exception bawaan Java, namun karena disini fokus kita adalah belajar custom exception, maka contoh ini bisa digunakan.</p> <p>Exception <code>AngkaKelewatBatas</code> akan terpicu ketika blok <code>if</code> mendeteksi bahwa terdapat nilai dari variabel <code>a</code> atau <code>b</code> yang nilainya ada diatas <code>1000000</code>. Jika hal itu terjadi, maka blok <code>if</code> akan dijalankan, dan melemparkan exception dengan cara membuat objek class baru berupa <code>AngkaKelewatBatas()</code> sekalian memberikan message didalamnya.</p> <p>Ketika terjadi exception, alur program akan langsung berpindah ke block <code>catch</code> yang sesuai. Karena yang mentrigger exception adalah exception <code>AngkaKelewatBatas</code>, maka blok <code>catch</code> terakhir akan dieksekusi, menghasilkan output berupa:</p> <pre><code>Masukkan dua angka:\n1\n10000000\nError: Angka melebihi batas!\n</code></pre>"},{"location":"exception-handling/02-Kasus-throws-dan-try-catch/#3-kasus-3-multiple-exception","title":"3 | Kasus 3 - Multiple Exception","text":"<p>Sebelumnya kita sudah menambahkan dua jenis exception pada fungsi <code>coba()</code>. Sekarang, kita akan mencoba menanganinya lebih banyak lagi secara bersamaan.</p> <p>Sejatinya kita bisa menaruh beberapa exception, semisal kita menambahkan 2 fungsi atau method berikut ke dalam file <code>Handler.java</code> sebelumnya.</p> <p>Berikut contoh fungsi <code>cobaBagi()</code> dan <code>bagi()</code> yang menggunakan tiga jenis exception sekaligus:</p> <pre><code>float cobaBagi() throws InputMismatchException, AngkaKelewatBatas, ArithmeticException {\n    System.out.println(\"Masukkan dua angka: \");\n\n    float a = scan.nextFloat();\n    if(a &gt; 1_000_000){\n        throw new AngkaKelewatBatas(\"Angka melebihi batas!\");\n    }\n\n    float b = scan.nextFloat();\n    if(b &gt; 1_000_000){\n        throw new AngkaKelewatBatas(\"Angka melebihi batas!\");\n    }\n\n    if(b==0){\n        throw new ArithmeticException(\"Pembagi tidak boleh kosong!\");\n    }\n\n    return a/b;\n}\n\nvoid bagi() {\n    float ans;\n    try {\n        ans = cobaBagi();\n        System.out.println(\"Hasil: \" + ans);\n    } catch (InputMismatchException e) {\n        System.out.println(\"Error: \" + e.getMessage());\n    } catch (ArithmeticException e) {\n        System.out.println(\"Error: \" + e.getMessage());\n    } catch (AngkaKelewatBatas e) {\n        System.out.println(\"Error: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Kita menambahkanya menjadi 3 exception sekaligus, dan itu bisa.</p> <p>Info lagi, ada beberapa exception yang bisa diberikan message, ada juga yang tidak. Pada contoh di atas, <code>ArithmeticException</code> bisa diberikan message langsung karena konstruktor-nya mendukung parameter <code>String</code>. Sedangkan <code>InputMismatchException</code> tidak memiliki konstruktor seperti itu, sehingga kita tidak bisa menambahkan pesan custom tanpa membuat subclass baru. Caranya adalah membuat sub-class dari <code>InputMismatchException</code>, atau dengan kata lain membuat custom exception. Misal seperti ini:</p> <pre><code>class InputTidakValid extends InputMismatchException {\n    public InputTidakValid(String msg) {\n        super(msg);\n    }\n}\n</code></pre> <p>Lalu apa gunanya message? Kegunaan dari message ini adalah untuk memberikan keterangan tambahan, yang bisa ditampilkan pada blok <code>catch</code> dengan <code>e.getMessage()</code>.</p> <p>Tambahan lagi, jika dirasa beberapa exception bisa digabung menjadi satu, dan keterangan message dibedakan dari isi dari <code>e.getMessage()</code>, maka kita bisa menggabungkan beberapa blok <code>catch</code> sebagai berikut:</p> <p><pre><code>void bagi() {\n    float ans;\n    try {\n        ans = cobaBagi();\n        System.out.println(\"Hasil: \" + ans);\n    } catch (InputMismatchException | AngkaKelewatBatas | ArithmeticException e) {\n        System.out.println(\"Error: \" + e.getMessage());\n    } \n}\n</code></pre> Pendekatan multi-catch ini berguna jika penanganan semua exception tersebut sama, misalnya hanya menampilkan pesan error umum dari <code>getMessage()</code>.</p> <p>Berikut adalah contoh input dan outputnya, ketika pembagi adalah <code>0</code>:</p> <pre><code>Masukkan dua angka: \n90\n0\nError: Pembagi tidak boleh kosong!\n</code></pre> <p>Atau ketika angka melebihi batas:</p> <pre><code>Masukkan dua angka: \n10000000\nError: Angka melebihi batas!\n</code></pre>"},{"location":"java-basic/01-Basic-Syntax/","title":"Basic Syntax","text":"<p>Pada materi kali ini, kita akan belajar hal-hal yang sangat basic, yaitu jenis-jenis variabel, dan aturan penamaan variabel. Walaupun sederhana, namun penting untuk dipahami sebelum memulai materi Java yang lain.</p>"},{"location":"java-basic/01-Basic-Syntax/#1-variables","title":"1 | Variables","text":"<p>Seperti yang telah kamu pelajari pada bagian sebelumnya, sebuah objek menyimpan state-nya di dalam field.</p> <pre><code>int cadence = 0;\nint speed = 0;\nint gear = 1;\n</code></pre> <p>Pembahasan \u201cWhat Is an Object?\u201d telah memperkenalkan kamu pada konsep field, tetapi mungkin kamu masih memiliki beberapa pertanyaan, seperti: Apa saja aturan dan konvensi penamaan sebuah field? Selain <code>int</code>, tipe data apa lagi yang tersedia? Apakah sebuah field harus diinisialisasi saat dideklarasikan? Apakah field akan otomatis memiliki nilai bawaan jika tidak diberi nilai secara eksplisit?</p> <p>Kita akan membahas jawaban dari pertanyaan-pertanyaan tersebut di bagian ini. Namun sebelum itu, ada beberapa perbedaan teknis yang perlu kamu pahami terlebih dahulu. Dalam bahasa pemrograman Java, istilah \u201cfield\u201d dan \u201cvariable\u201d sama-sama digunakan \u2014 dan hal ini sering menjadi sumber kebingungan bagi pengembang pemula, karena keduanya tampak merujuk pada hal yang sama.</p> <p>Bahasa pemrograman Java mendefinisikan beberapa jenis variabel sebagai berikut:</p>"},{"location":"java-basic/01-Basic-Syntax/#11-variabel-instans-instance-variables-non-static-fields","title":"1.1 | Variabel Instans (Instance Variables / Non-Static Fields)","text":"<p>Secara teknis, objek menyimpan keadaan (state) masing-masing di dalam non-static field, yaitu field yang dideklarasikan tanpa menggunakan kata kunci <code>static</code>. Non-static field juga disebut variabel instans, karena nilainya unik untuk setiap instans dari suatu kelas (atau dengan kata lain, untuk setiap objek). Sebagai contoh, nilai <code>currentSpeed</code> pada satu objek sepeda tidak akan sama dengan <code>currentSpeed</code> pada objek sepeda lainnya.</p>"},{"location":"java-basic/01-Basic-Syntax/#12-variabel-kelas-class-variables-static-fields","title":"1.2 | Variabel Kelas (Class Variables / Static Fields)","text":"<p>Variabel kelas adalah field apa pun yang dideklarasikan dengan modifier <code>static</code>. Kata kunci ini memberi tahu kompiler bahwa hanya ada satu salinan variabel tersebut di seluruh program, tidak peduli berapa kali kelas tersebut dibuat instansinya.</p> <p>Sebagai contoh, field yang menyimpan jumlah gigi (gear) untuk jenis sepeda tertentu bisa ditandai sebagai <code>static</code>, karena secara konsep jumlah gigi tersebut sama untuk semua objek sepeda dari kelas tersebut.</p> <p>Kode berikut akan membuat field <code>static</code> seperti itu:</p> <pre><code>static int numGears = 6;\n</code></pre> <p>Selain itu, kata kunci <code>final</code> dapat ditambahkan untuk menunjukkan bahwa nilai jumlah gigi tersebut tidak akan pernah berubah, misalnya:</p> <pre><code>static final int numGears = 6;\n</code></pre>"},{"location":"java-basic/01-Basic-Syntax/#13-variabel-lokal-local-variables","title":"1.3 |  Variabel Lokal (Local Variables)","text":"<p>Sama seperti objek yang menyimpan state-nya dalam field, sebuah metode sering kali menyimpan state sementara di dalam variabel lokal. Sintaks deklarasi variabel lokal mirip dengan deklarasi field, misalnya:</p> <pre><code>int count = 0;\n</code></pre> <p>Tidak ada kata kunci khusus untuk menandai sebuah variabel sebagai local; hal itu ditentukan sepenuhnya oleh lokasi deklarasinya \u2014 yaitu, di antara tanda kurung kurawal pembuka dan penutup dari suatu metode.</p> <p>Karena itu, variabel lokal hanya dapat diakses di dalam metode tempat ia dideklarasikan, dan tidak dapat digunakan oleh bagian lain dari kelas tersebut.</p>"},{"location":"java-basic/01-Basic-Syntax/#14-parameter-parameters","title":"1.4 | Parameter (Parameters)","text":"<p>Kamu sebenarnya sudah melihat contoh parameter, baik pada kelas <code>Bicycle</code> maupun pada metode <code>main</code> di aplikasi \u201cHello World!\u201d. Ingat kembali, signature dari metode <code>main</code> adalah:</p> <pre><code>public static void main(String[] args)\n</code></pre> <p>Di sini, variabel <code>args</code> merupakan parameter dari metode tersebut.</p> <p>Hal penting yang perlu diingat adalah bahwa parameter selalu diklasifikasikan sebagai \u201cvariabel\u201d, bukan field. Prinsip ini juga berlaku untuk konstruk yang menerima parameter lainnya \u2014 seperti konstruktor dan penangan pengecualian (exception handler) \u2014 yang akan kamu pelajari lebih lanjut di bagian-bagian berikutnya dari tutorial ini.</p> <p>Jika pembahasan mengacu pada field secara umum (tidak termasuk local variable dan parameter), maka istilah yang digunakan cukup field. Jika pembahasan berlaku untuk semua jenis variabel, maka akan digunakan istilah variable. Apabila konteks membutuhkan pembedaan yang lebih spesifik, maka akan disebutkan secara jelas\u2014misalnya static field, local variable, dan sebagainya.</p> <p>Kadang kamu juga akan menjumpai istilah member. Sebuah type (tipe data atau kelas) memiliki member yang mencakup field, method, dan nested type (tipe yang dideklarasikan di dalam tipe lain).</p>"},{"location":"java-basic/01-Basic-Syntax/#2-naming-variables","title":"2 | Naming Variables","text":"<p>Setiap bahasa pemrograman memiliki aturan dan konvensinya sendiri untuk penamaan, dan Java tidak berbeda. Aturan serta konvensi dalam menamai variabel di Java dapat diringkas sebagai berikut:</p> <ol> <li>Nama variabel bersifat case-sensitive, artinya huruf besar dan huruf kecil dianggap berbeda.    Sebuah nama variabel dapat berupa pengenal (identifier) apa pun yang sah\u2014yakni urutan huruf dan angka Unicode dengan panjang tak terbatas, diawali dengan huruf, tanda dolar (<code>$</code>), atau garis bawah (<code>_</code>).    Namun, konvensinya adalah selalu memulai nama variabel dengan huruf, bukan dengan <code>$</code> atau <code>_</code>.</li> </ol> <p>Tanda dolar hampir tidak pernah digunakan dalam penamaan variabel.    Kamu mungkin menemukannya pada nama yang dibuat otomatis oleh compiler atau framework, tapi sebaiknya hindari penggunaannya saat menulis kode sendiri.    Hal yang sama berlaku untuk garis bawah (<code>_</code>): secara teknis boleh, tapi secara gaya penulisan tidak disarankan.    Selain itu, spasi tidak diizinkan dalam nama variabel.</p> <ol> <li>Karakter berikutnya setelah karakter pertama boleh berupa huruf, angka, tanda dolar, atau garis bawah.    Meski begitu, gunakan akal sehat dan konvensi umum saat memilih nama. Gunakan kata yang jelas dan lengkap daripada singkatan yang tidak jelas.    Langkah ini membuat kode lebih mudah dibaca dan dipahami, bahkan bisa membuatnya self-documenting.</li> </ol> <p>Sebagai contoh, nama variabel seperti <code>cadence</code>, <code>speed</code>, dan <code>gear</code> jauh lebih intuitif dibandingkan versi singkat seperti <code>c</code>, <code>s</code>, dan <code>g</code>.    Ingat juga, nama variabel tidak boleh menggunakan kata kunci (keyword) atau kata yang sudah dipesan (reserved word) oleh Java.</p> <ol> <li>Jika nama variabel hanya terdiri dari satu kata, tulislah seluruhnya dengan huruf kecil.    Jika terdiri dari lebih dari satu kata, kapitalisasi huruf pertama dari setiap kata berikutnya.    Contohnya: <code>gearRatio</code> dan <code>currentGear</code>.    Konvensi ini dikenal sebagai camelCase.</li> </ol> <p>Namun, jika variabel menyimpan nilai konstan (misalnya <code>static final int NUM_GEARS = 6;</code>), maka konvensinya sedikit berbeda: semua huruf ditulis kapital, dan setiap kata dipisahkan dengan garis bawah (<code>_</code>).    Perlu diingat, garis bawah sebaiknya hanya digunakan dalam konteks seperti ini.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/","title":"Lifecycle of a Program","text":"<p>Jika kamu membaca tulisan ini, kemungkinan besar kamu sudah tahu cara menulis kode Java. Itu hal yang bagus \u2014 menurutku, semua orang seharusnya tahu cara menulis kode di zaman sekarang, sama seperti semua orang perlu tahu operasi matematika dasar seperti <code>+</code>, <code>-</code>, <code>*</code>, dan <code>/</code>, meskipun kita semua punya kalkulator.</p> <p>Pada tulisan sebelumnya, aku sudah membahas bagaimana kode Java pertama-tama \u201cdikompilasi\u201d menjadi bytecode, lalu diinterpretasikan dan dijalankan oleh JVM (Java Virtual Machine). Namun, waktu itu aku belum menjelaskan bagaimana JVM sebenarnya melakukan proses eksekusi bytecode tersebut.</p> <p>Tujuan dari artikel ini adalah untuk menjelaskan hal itu \u2014 menjawab pertanyaan: \u201cApa yang sebenarnya terjadi ketika kita menekan tombol \u2018Run\u2019 atau \u2018Execute\u2019 di IDE favorit kita?\u201d</p> <p>Setelah membaca tulisan ini, kamu akan memahami siklus eksekusi (execution lifecycle) dari sebuah aplikasi Java, serta aktivitas-aktivitas yang dilakukan JVM selama tahap eksekusi tersebut.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#1-execution-lifecycle","title":"1 | Execution Lifecycle","text":"<p>Siklus eksekusi dari sebuah aplikasi Java secara umum dapat dibagi menjadi tiga tahap utama:</p> <ol> <li>Kompilasi \u2013 Kode sumber aplikasi dikonversi menjadi bytecode menggunakan compiler <code>javac</code>.</li> <li>Pemanggilan Kelas (Class Loading) \u2013 Bytecode dimuat ke dalam memori, dan berkas-berkas kelas yang diperlukan dipersiapkan untuk dijalankan.</li> <li>Eksekusi Bytecode \u2013 JVM mengeksekusi bytecode sehingga program dapat berjalan.</li> </ol> <p>Tahap terakhir ini sepenuhnya menjadi tanggung jawab Java Virtual Machine (JVM). JVM menangani proses pemuatan bytecode, pengalokasian memori, serta konversi bytecode menjadi native machine code (kode mesin yang dapat dijalankan oleh prosesor).</p> <p>Dengan kata lain, JVM bertugas menerjemahkan bytecode ke dalam instruksi mesin yang spesifik untuk platform tempat program dijalankan. Proses ini cukup kompleks karena setiap arsitektur prosesor memiliki kumpulan instruksi yang berbeda\u2014misalnya x86, ARM, MIPS, atau PowerPC.</p> <p>Selain itu, JVM juga menyediakan berbagai layanan runtime seperti manajemen memori, sinkronisasi thread, dan penanganan exception.</p> <p>Tulisan ini akan berfokus pada tahap eksekusi bytecode.</p> <p>Diagram aktivitas berikut menggambarkan apa yang terjadi selama tahap ini:</p> <p></p> <p>Bagian-bagian berikut menjelaskan lebih detail setiap aktivitas yang terjadi selama tahap eksekusi bytecode.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#11-loading","title":"1.1 | Loading","text":"<p>Loading adalah proses menemukan bentuk biner dari sebuah kelas atau interface (yaitu file dalam format <code>.class</code>) berdasarkan nama tertentu, lalu membangun sebuah objek <code>Class</code> dari bentuk biner tersebut.</p> <p>JVM menggunakan ClassLoader untuk menemukan representasi biner dari kelas, misalnya <code>Main</code>. Kelas <code>ClassLoader</code> dan seluruh subclass-nya bertanggung jawab atas proses loading ini. Metode <code>defineClass</code> dipanggil untuk membangun objek <code>Class</code> dari representasi biner berkas <code>.class</code>.</p> <p>JVM menyediakan dua jenis class loader bawaan:</p> <ul> <li>Bootstrap Class Loader, yaitu class loader inti yang memuat kelas-kelas dasar Java dari berkas <code>rt.jar</code>.</li> <li>Extension Class Loader, yang memuat kelas-kelas tambahan dari direktori <code>ext</code>.</li> </ul> <p>Selain itu, ada juga Application Class Loader, yang digunakan untuk memuat kelas dari lokasi lain, seperti classpath atau server jarak jauh. Class loader jenis ini biasanya merupakan subclass dari <code>ClassLoader</code> yang telah dikustomisasi, dan dapat memuat kelas melalui instance dari <code>java.lang.Class</code>.</p> <pre><code>public class CustomClassLoader extends ClassLoader {\n  public CustomClassLoader(ClassLoader parent) {\n    super(parent);\n  }\n  // Method to load a class given its name\n  public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {\n    if (!name.startsWith(\"com.example\")) {\n      // Delegate to the parent class loader\n      return super.loadClass(name);\n      }\n    // The class name does start with \"com.example\", construct the file name\n    String fileName = name.substring(name.lastIndexOf('.') + 1) + \".class\";\n    // Try to open an InputStream for the file\n    InputStream inputStream = getClass().getResourceAsStream(fileName);\n    // If the stream is null, throw a ClassNotFoundException\n    if (inputStream == null) {\n      throw new ClassNotFoundException();\n    }\n    try {\n      // Create a byte array to hold the contents of the file\n      byte[] bytes = new byte[inputStream.available()];\n      // Read the bytes from the input stream\n      inputStream.read(bytes);\n      // Define the class using the class name, the byte array, and the number of bytes\n      return defineClass(name, bytes, 0, bytes.length);\n    } catch (IOException e) {\n      throw new ClassNotFoundException();\n    }\n  }\n}\n</code></pre> <p>Kelas ini merupakan turunan dari <code>ClassLoader</code> dan menimpa metode <code>loadClass</code> untuk memberikan perilaku khusus dalam proses pemuatan kelas. Pertama, metode ini memeriksa apakah nama kelas dimulai dengan <code>com.example</code>. Jika tidak, proses pemuatan akan diteruskan ke parent class loader. Namun jika ya, maka metode ini akan membentuk nama file yang sesuai dan mencoba membuka <code>InputStream</code> untuk file tersebut.</p> <p>Jika berhasil, class loader membaca data biner dari input stream dan memanggil metode <code>defineClass</code> untuk mendefinisikan kelas tersebut. Jika gagal, ia akan melemparkan <code>ClassNotFoundException</code>.</p> <p>Secara ringkas, proses class loading melakukan tiga fungsi utama berikut:</p> <ol> <li>Membuat aliran biner (binary stream) dari berkas <code>.class</code>.</li> <li>Melakukan parsing terhadap data biner tersebut sesuai dengan struktur data internal Java.</li> <li>Membuat sebuah instance dari <code>java.lang.Class</code>.</li> </ol> <p>Setelah ketiga langkah ini selesai, objek kelas (class instance) siap untuk masuk ke tahap berikutnya, yaitu linking.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#12-linking","title":"1.2 | Linking","text":"<p>Linking adalah proses menggabungkan bentuk biner dari suatu kelas atau interface ke dalam runtime state JVM agar dapat dieksekusi. Tahap ini terdiri dari tiga langkah utama: verifikasi, preparasi, dan (opsional) resolusi dari referensi simbolik.</p> <ol> <li>Verifikasi (Verification)    Pada tahap ini, JVM memeriksa apakah representasi kelas yang dimuat sudah terbentuk dengan benar dan memiliki symbol table yang valid.    JVM juga memastikan bahwa kode yang mengimplementasikan kelas tersebut mematuhi aturan semantik dari bahasa Java dan JVM.</li> </ol> <p>Misalnya, JVM akan memeriksa bahwa:</p> <pre><code>* setiap instruksi memiliki *opcode* yang valid,\n* setiap instruksi *branch* mengarah ke awal instruksi lain (bukan ke tengah-tengahnya),\n* setiap metode memiliki *signature* yang benar.\n</code></pre> <p>Dengan kata lain, tahap ini memastikan bahwa bytecode yang dimuat aman dan dapat dijalankan tanpa melanggar aturan sistem.</p> <ol> <li> <p>Persiapan (Preparation)    Pada tahap ini, JVM membuat static fields (variabel dan konstanta kelas) untuk setiap kelas atau interface, lalu menginisialisasi semuanya dengan nilai bawaan (default).    Proses ini juga melibatkan pengalokasian ruang memori untuk static storage serta pembuatan struktur data internal yang digunakan oleh JVM, seperti method tables.</p> </li> <li> <p>Resolusi (Resolution)    Resolusi adalah proses memeriksa symbolic references dari suatu kelas terhadap kelas dan interface lain yang dirujuk di dalamnya.    JVM akan memuat kelas atau interface yang disebutkan tersebut (jika belum dimuat) dan memverifikasi bahwa setiap referensi benar dan konsisten.</p> </li> </ol> <p>Dalam implementasi sederhana bahasa C, proses static linkage menghasilkan program yang sudah sepenuhnya tertaut (fully linked). Artinya, semua tautan ke rutin pustaka (library routines) yang digunakan program sudah diselesaikan secara penuh, dan salinannya disertakan langsung di dalam berkas hasil kompilasi, seperti <code>a.out</code>.</p> <p>Sebaliknya, dalam Java, referensi simbolik (symbolic references) tidak langsung diselesaikan pada saat kompilasi atau linking. Proses ini dilakukan hanya ketika referensi tersebut benar-benar digunakan \u2014 pendekatan ini disebut lazy resolution.</p> <p>Sebagai contoh, jika sebuah kelas memiliki beberapa referensi simbolik ke kelas lain, maka tiap referensi bisa saja diselesaikan satu per satu saat digunakan, atau bahkan tidak pernah diselesaikan sama sekali, apabila referensi tersebut tidak pernah dipakai selama program dijalankan.</p> <p>Secara ringkas, proses linking terdiri dari tiga tahap:</p> <ol> <li>Verifikasi (Verification)</li> <li>Persiapan (Preparation)</li> <li>Resolusi (Resolution) \u2014 bersifat opsional</li> </ol> <p>Setelah ketiga tahap ini selesai, kelas siap untuk masuk ke tahap inisialisasi (Initialization).</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#13-initialization","title":"1.3 | Initialization","text":"<p>Initialization adalah proses mengeksekusi static initializer dan initializer untuk static fields (variabel kelas) yang dideklarasikan di dalam kelas. Semua static initializer dijalankan sesuai urutan kemunculannya di dalam kode sumber.</p> <p>Perhatikan contoh berikut: ketika JVM melakukan inisialisasi terhadap kelas <code>Main</code>, ia terlebih dahulu menginisialisasi semua superclass-nya, dimulai dari <code>Object</code>. Karena <code>Object</code> tidak memiliki superclass, proses rekursi berhenti di sana.</p> <p>Setelah itu, JVM melanjutkan inisialisasi kelas <code>Main</code> dengan mengeksekusi class variable initializer dan static initializer dalam urutan yang sama seperti di kode sumber.</p> <p>Dalam contoh ini:</p> <ul> <li>initializer untuk variabel kelas <code>x</code> dijalankan terlebih dahulu,</li> <li>kemudian blok static initializer,</li> <li>dan terakhir initializer untuk variabel kelas <code>z</code>.</li> </ul> <p>Setelah seluruh kelas selesai diinisialisasi, barulah metode <code>main</code> dapat dijalankan.</p> <pre><code>class Main extends Object {\n  // Class variable initializers and static initializers are executed in this order\n  static int x = 1;  // Initializer untuk field statik x\n  static int y;      // Field statik y tanpa initializer\n\n  // Static initializer block\n  static {\n    y = x + 1;\n  }\n\n  static int z = x + y;  // Initializer untuk field statik z\n\n  public static void main(String[] args) {\n    // Metode main dijalankan setelah kelas selesai diinisialisasi\n    System.out.println(\"x = \" + x);\n    System.out.println(\"y = \" + y);\n    System.out.println(\"z = \" + z);\n  }\n}\n</code></pre> <p>Secara umum, inisialisasi sebuah kelas atau antarmuka <code>T</code> akan terjadi ketika salah satu dari kondisi berikut terpenuhi:</p> <ul> <li>Sebuah instans dari <code>T</code> dibuat.</li> <li>Sebuah metode statik dari <code>T</code> dipanggil.</li> <li>Sebuah field statik dari <code>T</code> diubah nilainya (assigned).</li> <li>Sebuah field statik dari <code>T</code> digunakan, dan field tersebut bukan konstanta (<code>final static</code> dengan nilai tetap).</li> </ul> <p>Selain itu, pemanggilan metode melalui refleksi (misalnya menggunakan <code>java.lang.reflect.Method</code>) juga akan memicu inisialisasi kelas.</p> <p>Setelah semua kelas yang diperlukan telah diinisialisasi, JVM melanjutkan ke tahap instansiasi, yaitu pembuatan objek dari kelas-kelas tersebut.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#14-instantiating","title":"1.4 | Instantiating","text":"<p>Sebuah instans kelas baru secara eksplisit dibuat ketika ekspresi pembentukan objek dievaluasi \u2014 misalnya saat menggunakan operator <code>new</code>.</p> <p>Namun, instans juga bisa terbentuk secara implisit, dalam beberapa situasi berikut:</p> <ul> <li>Saat memuat kelas atau antarmuka yang berisi string literal atau text block, JVM dapat membuat objek <code>String</code> baru.</li> <li>Saat terjadi boxing conversion, misalnya mengubah <code>int</code> menjadi <code>Integer</code>, JVM membuat objek dari kelas pembungkus (wrapper class).</li> <li>Saat melakukan operasi konkatenasi string, JVM dapat membuat objek <code>String</code> baru untuk menampung hasilnya.</li> <li>Saat mengevaluasi ekspresi method reference atau lambda, JVM membuat objek dari functional interface yang sesuai.</li> </ul> <p>Contoh eksplisitnya seperti berikut:</p> <pre><code>Point magicPoint = new Point(42, 42);\n</code></pre> <p>Selama proses instansiasi, JVM menjalankan langkah-langkah berikut:</p> <ol> <li>Mengalokasikan memori di heap untuk menyimpan objek baru.</li> <li>Memanggil konstruktor kelas untuk menginisialisasi objek tersebut.</li> <li>Mengembalikan referensi ke objek baru yang telah dibuat.</li> </ol>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#15-finalizing","title":"1.5 | Finalizing","text":"<p>Finalization adalah proses untuk membersihkan sumber daya yang digunakan oleh sebuah objek dan mempersiapkannya sebelum dilakukan garbage collection.</p> <p>Kelas <code>Object</code> di Java mendefinisikan sebuah metode bernama <code>finalize()</code>, yang akan dipanggil oleh garbage collector saat sebuah objek akan dihapus dari memori. Metode ini dapat di-override oleh subclass untuk menjalankan aksi pembersihan tertentu sebelum objek benar-benar dihapus.</p> <p>Contoh berikut menunjukkan kelas <code>TempFile</code> yang menimpa (<code>override</code>) metode <code>finalize()</code> agar file sementara dihapus otomatis saat objeknya dikoleksi oleh garbage collector:</p> <pre><code>public class TempFile {\n  private File file;\n\n  public TempFile(String filename) {\n    file = new File(filename);\n  }\n\n  @Override\n  protected void finalize() throws Throwable {\n    // Hapus file ketika objek TempFile dikoleksi oleh garbage collector\n    file.delete();\n    super.finalize();\n  }\n}\n</code></pre> <p>Contoh di atas bisa berguna jika kamu ingin memastikan bahwa file sementara selalu dihapus ketika tidak lagi dibutuhkan. Namun, penting untuk diingat bahwa metode <code>finalize()</code> tidak dijamin akan selalu dipanggil. Karena itu, metode ini tidak boleh diandalkan untuk tugas penting seperti menutup koneksi database, menulis data terakhir ke file, atau melepaskan sumber daya kritis lainnya.</p> <p>Sebagai gantinya, praktik modern di Java lebih menyarankan untuk menggunakan:</p> <ul> <li><code>try-with-resources</code> (untuk menutup sumber daya otomatis), atau</li> <li>blok <code>finally</code> (untuk menjamin pembersihan manual tetap dilakukan).</li> </ul> <p>Unloading adalah proses menghapus kelas atau interface dari runtime state JVM \u2014 biasanya terjadi ketika class loader yang mendefinisikan kelas tersebut dikoleksi oleh garbage collector. Tujuan utamanya adalah menghemat memori, dan biasanya hanya terasa manfaatnya pada aplikasi besar yang sering memuat banyak kelas sementara (misalnya server aplikasi modular atau plugin-based).</p> <p>Berikut contoh kode yang menggambarkan user-defined garbage collection, dengan kelas <code>LargeClass</code> yang berisi array berukuran besar dan mengonsumsi banyak memori:</p> <pre><code>import java.lang.ref.WeakReference;\n\npublic class LargeClass {\n  // Array besar yang memakan banyak memori\n  private int[] data = new int[Integer.MAX_VALUE / 10];\n\n  public static void main(String[] args) {\n    // Membuat objek LargeClass dan menyimpannya dalam weak reference\n    LargeClass largeObject = new LargeClass();\n    WeakReference&lt;LargeClass&gt; weakRef = new WeakReference&lt;&gt;(largeObject);\n    largeObject = null;  // Tidak lagi memiliki referensi kuat\n\n    // Memicu garbage collector secara manual\n    System.gc();\n\n    // Mengecek apakah objek LargeClass telah dikoleksi\n    if (weakRef.get() == null) {\n      System.out.println(\"The LargeClass object has been collected\");\n    } else {\n      System.out.println(\"The LargeClass object has not been collected\");\n    }\n  }\n}\n</code></pre> <p>Jika objek <code>LargeClass</code> telah dikoleksi oleh garbage collector, maka output-nya akan:</p> <p><code>The LargeClass object has been collected</code> Sebaliknya, jika belum dikoleksi: <code>The LargeClass object has not been collected</code></p> <p>Perlu diingat:</p> <ul> <li>Kelas dan interface yang dimuat oleh bootstrap class loader tidak pernah di-unload.</li> <li>Pada aplikasi biasa (non-modular), proses unloading jarang terjadi karena system class loader tetap aktif sepanjang umur aplikasi.</li> </ul> <p>Berbeda dari garbage collection yang menghapus objek, class unloading menghapus definisi kelas (objek <code>Class</code> dan metadata-nya dari memori JVM). Ini hanya bisa terjadi bila:</p> <ol> <li>Class loader yang memuat kelas tersebut sudah tidak direferensikan lagi.</li> <li>Garbage collector menandainya untuk dikoleksi.</li> </ol> <p>Contoh di bawah ini memperlihatkan situasi di mana class unloading sangat mungkin terjadi \u2014 biasanya dengan menggunakan custom class loader yang dimuat dan dibuang secara dinamis.</p> <pre><code>import java.lang.ref.WeakReference;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class ClassUnloadingExample {\n  public static void main(String[] args) throws Exception {\n    // Jalur menuju file .class (pastikan sudah diatur dengan benar)\n    URL classUrl = new URL(\"file:///path/to/LargeClass.class\");\n\n    // Membuat class loader khusus untuk memuat \"LargeClass\"\n    URLClassLoader customClassLoader = new URLClassLoader(new URL[]{classUrl});\n\n    // Memuat \"LargeClass\" menggunakan class loader khusus\n    Class&lt;?&gt; largeClass = Class.forName(\"LargeClass\", true, customClassLoader);\n\n    // Membuat weak reference ke class loader khusus\n    WeakReference&lt;ClassLoader&gt; weakClassLoaderRef = new WeakReference&lt;&gt;(customClassLoader);\n\n    // Menghapus semua referensi kuat ke class loader dan class tersebut\n    customClassLoader = null;\n    largeClass = null;\n\n    // Menyarankan JVM untuk menjalankan garbage collector\n    System.gc();\n\n    // Menunggu sebentar untuk meningkatkan kemungkinan GC dijalankan\n    Thread.sleep(1000);\n\n    // Mengecek apakah class loader khusus sudah dikoleksi oleh garbage collector\n    if (weakClassLoaderRef.get() == null) {\n      System.out.println(\"Custom class loader telah dikoleksi oleh garbage collector, menandakan bahwa LargeClass mungkin telah di-unload\");\n    } else {\n      System.out.println(\"Custom class loader masih ada di memori\");\n    }\n  }\n}\n</code></pre> <p>Pada contoh sebelumnya, custom class loader digunakan untuk memuat <code>LargeClass.class</code>, kemudian semua referensi terhadap class loader tersebut dihapus, sehingga ia memenuhi syarat untuk dikoleksi oleh garbage collector. Program kemudian memeriksa apakah custom class loader tersebut sudah dikoleksi dengan cara mengecek objek <code>WeakReference</code>. Jika <code>customClassLoader</code> telah dikoleksi, maka besar kemungkinan kelas yang dimuatnya (<code>LargeClass</code>) juga telah di-unload.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#2-program-exit","title":"2 | Program Exit","text":"<p>Program exit mengacu pada proses penghentian eksekusi program. Ini berarti semua thread yang bukan daemon thread akan dihentikan, atau ada thread yang memanggil metode <code>exit()</code> dari kelas <code>Runtime</code>. Metode ini menghentikan JVM dan keluar dengan kode keluar (exit code) yang ditentukan. Namun, penggunaan metode ini dibatasi oleh security manager. Jika ada security manager dan ia tidak mengizinkan program untuk keluar, maka pemanggilan <code>exit()</code> akan melempar <code>SecurityException</code>.</p>"},{"location":"java-basic/02-Lifecycle-of-a-Program/#3-kesimpulan","title":"3 | Kesimpulan","text":"<p>Dalam artikel ini, kita telah membahas lebih dalam tentang siklus eksekusi aplikasi Java. Seperti yang dijelaskan, ada banyak tahap yang dilakukan sebelum metode <code>main()</code> dijalankan. Mulai dari class loading, linking, initializing, hingga unloading, JVM melakukan serangkaian langkah kompleks untuk memastikan program berjalan dengan benar.</p> <p>Pemahaman ini penting bagi pengembang agar lebih mengerti bagaimana JVM bekerja di balik layar dan bagaimana cara mengoptimalkan aplikasi Java. Semoga artikel ini membantu kamu memahami lebih dalam \u2014 dan semoga kamu menikmati proses belajarnya \ud83d\ude0e.</p>"},{"location":"java-basic/03-Data-Types-and-Variables/","title":"Data types and Variables","text":"<p>Java punya empat jenis variabel utama: non-static fields (instance variables), static fields (class variables), local variables, dan parameters. Tiap jenis punya scope dan lifetime berbeda \u2014 sangat menentukan kapan variabel ada dan kapan harus diinisialisasi.</p>"},{"location":"java-basic/03-Data-Types-and-Variables/#1-deklarasi-inisialisasi","title":"1 | Deklarasi &amp; inisialisasi","text":"<ul> <li>Bentuk umum: <code>type name;</code> atau <code>type name = value;</code>. Contoh:</li> </ul> <p><pre><code>int myInt;          // deklarasi\nint myOther = 5;    // deklarasi + inisialisasi\nString s = \"Hi\";\n</code></pre> * Untuk tipe primitif: <code>byte, short, char, int, long, float, double, boolean</code>. Untuk tipe objek: <code>String</code>, wrapper class (<code>Integer</code>, <code>Double</code>, ...), dan kelas user-defined.</p>"},{"location":"java-basic/03-Data-Types-and-Variables/#2-membaca-dan-menulis-assignmentreading","title":"2 | Membaca dan menulis (assignment/reading)","text":"<ul> <li>Assignment: <code>variableName = value;</code></li> <li>Baca variabel di ekspresi, parameter, dsb.</li> <li>Contoh kecil:</li> </ul> <pre><code>int a = 10;\nint b = a + 20;\nSystem.out.println(b);\n</code></pre> <p>(Ini dasar, tapi sering jadi sumber bug kalau lupa urutan inisialisasi.)</p>"},{"location":"java-basic/03-Data-Types-and-Variables/#3-naming-rules-conventions-praktikal","title":"3 | Naming rules &amp; conventions (praktikal)","text":"<ul> <li>Aturan formal: case-sensitive; harus dimulai huruf, <code>$</code>, atau <code>_</code>; karakter setelahnya boleh huruf/angka/<code>$</code>/<code>_</code>; tidak boleh pakai keyword Java.</li> <li> <p>Konvensi gaya (ikuti ini supaya kode enak dibaca):</p> <ul> <li>variabel biasa: <code>camelCase</code> (mis. <code>currentSpeed</code>)</li> <li>konstanta (<code>static final</code>): <code>ALL_CAPS_WITH_UNDERSCORES</code> (mis. <code>MAX_SIZE</code>)</li> <li>hindari memulai nama dengan <code>$</code> atau <code>_</code> (secara teknis boleh tapi jelek gaya)</li> </ul> </li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#4-scope-lifetime-hal-yang-sering-bikin-pusing","title":"4 | Scope &amp; lifetime \u2014 hal yang sering bikin pusing","text":"<ul> <li>Instance field: ada selama objek hidup (heap).</li> <li>Static field: ada selama kelas dimuat (satu salinan per kelas).</li> <li>Local variable: hanya ada di dalam metode/block tempat dideklarasikan; compiler mewajibkan inisialisasi sebelum dipakai (lihat bagian berikut).</li> <li>Parameter: variabel lokal yang nilainya dikirim saat pemanggilan metode.</li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#5-default-values-vs-wajib-inisialisasi","title":"5 | Default values vs wajib inisialisasi","text":"<ul> <li>Fields (instance &amp; static) yang tidak diberi nilai akan otomatis mendapat default value (mis. <code>0</code>, <code>false</code>, <code>null</code>) \u2014 tapi mengandalkan default sering dianggap gaya buruk; lebih baik inisialisasi eksplisit.</li> <li>Local variables tidak mendapat default \u2014 compiler mengharuskan kamu menginisialisinya sebelum digunakan. Ini mencegah bug akibat membaca memori tak terdefinisi. (Aturan JLS / compiler). </li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#6-tipe-inference-untuk-variabel-lokal-var","title":"6 | Tipe inference untuk variabel lokal (<code>var</code>)","text":"<ul> <li>Sejak Java 10 kamu bisa pakai <code>var</code> untuk variabel lokal:</li> </ul> <p><pre><code>var s = \"hello\";     // compiler tahu ini String\nvar list = new ArrayList&lt;String&gt;();\n</code></pre> * Batasannya: cuma untuk variabel lokal (termasuk for-loop index); bukan untuk fields atau parameter. Gunakan <code>var</code> untuk mengurangi verbosity, tapi jangan pakai kalau tipe jadi tidak jelas \u2014 itu malah menurunkan keterbacaan.</p>"},{"location":"java-basic/03-Data-Types-and-Variables/#7-primitive-vs-reference-autoboxing","title":"7 | Primitive vs Reference &amp; autoboxing","text":"<ul> <li>Variabel primitif menyimpan nilai langsung (mis. <code>int a = 5;</code>). Variabel referensi menyimpan alamat objek (mis. <code>String s = \"x\";</code>).</li> <li>Java mendukung autoboxing/unboxing: otomatis konversi antara primitif dan wrapper (<code>int</code> \u2194 <code>Integer</code>). Hati-hati: boxing bikin objek tambahan \u2192 overhead dan potensi <code>NullPointerException</code> saat unboxing dari <code>null</code>.</li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#8-common-pitfalls-practical-tips-baca-kalau-mau-cepat-mahir","title":"8 | Common pitfalls &amp; practical tips (baca kalau mau cepat mahir)","text":"<ul> <li>Jangan andalkan default field values untuk logika program \u2014 inisialisasi eksplisit membuat intent jelas. </li> <li>Local variables harus diinisialisasi sebelum dipakai \u2014 compiler cek alur kontrol; ini mencegah bug subtle.</li> <li>Gunakan <code>final</code> untuk variabel yang tidak berubah \u2014 ini dokumentasi yang bagus dan membantu compiler/optimizer.</li> <li>Hati-hati dengan <code>var</code>: bagus untuk local tersingkat, jelek bila tipe jadi tak jelas (mis. <code>var x = map.get(\"k\");</code> tanpa konteks).</li> <li>Boxing implicit: <code>List&lt;Integer&gt; list = Arrays.asList(1,2,3); int x = list.get(0);</code> \u2192 automatic unboxing; tapi <code>Integer i = null; int j = i;</code> \u2192 NPE.</li> <li>Thread safety: static mutable fields shared antar thread \u2192 potensi race condition. Gunakan synchronization/atomic types jika diperlukan.</li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#9-contoh-cheat-sheet-singkat","title":"9 | Contoh cheat-sheet singkat","text":""},{"location":"java-basic/03-Data-Types-and-Variables/#fields-public-class-bike-private-int-speed-0-instance-field-private-static-final-int-max-10-class-constant-local-variable-var-public-void-demo-int-a-5-var-s-hello-local-type-inferred-string-final-usage-final-int-x-10-tidak-bisa-di-reassign","title":"<pre><code>// fields\npublic class Bike {\n  private int speed = 0;             // instance field\n  private static final int MAX = 10; // class constant\n}\n\n// local variable + var\npublic void demo() {\n  int a = 5;\n  var s = \"hello\";  // local, type inferred -&gt; String\n}\n\n// final usage\nfinal int x = 10;   // tidak bisa di-reassign\n</code></pre>","text":""},{"location":"java-basic/03-Data-Types-and-Variables/#10-quick-checklist-sebelum-commit-pr","title":"10 | Quick checklist sebelum commit / PR","text":"<ul> <li>Nama variabel jelas dan konsisten? (camelCase / CONSTANT_STYLE)</li> <li>Variable scope minimal (jangan buat field kalau hanya dipakai local).</li> <li>Local variable terinisialisasi sebelum dipakai? (compiler biasanya nolak, tapi cek alur kompleks).</li> <li>Apakah boxing/unboxing bisa dihindari? (loop besar -&gt; prefer primitif).</li> <li>Mutable static fields aman antar-thread?</li> </ul>"},{"location":"java-basic/03-Data-Types-and-Variables/#11-sumber-bacaan-lanjut-penting","title":"11 | Sumber &amp; bacaan lanjut (penting)","text":"<ul> <li>Jenkov \u2014 Java Variables (halaman sumber utama ringkasan ini). (jenkov.com)</li> <li>Oracle Java Tutorial \u2014 Default values &amp; primitives. (Oracle Docs)</li> <li>Oracle Java Tutorial \u2014 Autoboxing &amp; Unboxing. (Oracle Docs)</li> <li>Java Language Specification / Oracle docs \u2014 aturan inisialisasi local variables. (Oracle Docs)</li> </ul>"},{"location":"java-basic/04-Variables-and-Scopes/","title":"Variable Scope in Java","text":"<p>Scope variabel adalah area atau jangkauan dalam kode program di mana sebuah variabel dapat diakses dan digunakan. Variabel yang dideklarasikan di luar fungsi (scope global) dapat diakses di mana saja, sedangkan variabel yang dideklarasikan di dalam fungsi (scope lokal) hanya dapat diakses dari dalam fungsi tersebut. Memahami scope membantu menghindari konflik penamaan dan mengelola variabel secara efektif.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#1-gambaran-umum","title":"1 | Gambaran Umum","text":"<p>Di Java, seperti di bahasa pemrograman lainnya, setiap variabel memiliki scope atau ruang lingkup. Ini adalah bagian dari program di mana variabel tersebut bisa digunakan dan berlaku.</p> <p>Dalam tutorial ini, kita akan memperkenalkan ruang lingkup yang tersedia di Java dan membahas perbedaan di antara mereka.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#2-class-scope-ruang-lingkup-kelas","title":"2 | Class Scope (Ruang Lingkup Kelas)","text":"<p>Setiap variabel yang dideklarasikan di dalam kurung kurawal kelas (<code>{}</code>) dengan modifier akses <code>private</code>, tapi di luar metode manapun, memiliki ruang lingkup kelas. Akibatnya, variabel ini bisa digunakan di seluruh kelas, tetapi tidak bisa diakses dari luar kelas:</p> <pre><code>public class ClassScopeExample {\n    private Integer amount = 0;\n\n    public void exampleMethod() {\n        amount++;\n    }\n\n    public void anotherExampleMethod() {\n        Integer anotherAmount = amount + 4;\n    }\n}\n</code></pre> <p>Di sini, <code>ClassScopeExample</code> memiliki variabel kelas <code>amount</code> yang bisa diakses dari semua metode dalam kelas tersebut.</p> <p>Jika kita tidak menggunakan <code>private</code>, variabel ini akan dapat diakses dari seluruh package. Lihat artikel tentang access modifiers untuk informasi lebih lanjut.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#3-method-scope-ruang-lingkup-metode","title":"3 | Method Scope (Ruang Lingkup Metode)","text":"<p>Jika sebuah variabel dideklarasikan di dalam metode, variabel tersebut hanya berlaku di dalam metode yang sama:</p> <pre><code>public class MethodScopeExample {\n    public void methodA() {\n        Integer area = 2;\n    }\n\n    public void methodB() {\n        // error compiler, area tidak bisa dikenali sebagai variabel\n        area = area + 2;\n    }\n}\n</code></pre> <p>Di <code>methodA</code>, kita membuat variabel metode bernama <code>area</code>. Oleh karena itu, kita hanya bisa menggunakan <code>area</code> di dalam <code>methodA</code>, dan tidak bisa digunakan di tempat lain.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#4-loop-scope-ruang-lingkup-loop","title":"4 | Loop Scope (Ruang Lingkup Loop)","text":"<p>Jika kita mendeklarasikan variabel di dalam loop, variabel tersebut hanya berlaku di dalam loop:</p> <pre><code>public class LoopScopeExample {\n    List&lt;String&gt; listOfNames = Arrays.asList(\"Joe\", \"Susan\", \"Pattrick\");\n\n    public void iterationOfNames() {\n        String allNames = \"\";\n        for (String name : listOfNames) {\n            allNames = allNames + \" \" + name;\n        }\n\n        // error compiler, name tidak bisa dikenali sebagai variabel\n        String lastNameUsed = name;\n    }\n}\n</code></pre> <p>Di sini, <code>name</code> adalah variabel metode yang hanya bisa digunakan di dalam loop dan tidak berlaku di luar loop.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#5-bracket-scope-ruang-lingkup-kurung","title":"5 | Bracket Scope (Ruang Lingkup Kurung)","text":"<p>Kita juga bisa mendefinisikan ruang lingkup tambahan menggunakan kurung <code>{}</code> di mana saja:</p> <pre><code>public class BracketScopeExample {    \n    public void mathOperationExample() {\n        Integer sum = 0;\n        {\n            Integer number = 2;\n            sum = sum + number;\n        }\n        // error compiler, number tidak bisa dikenali sebagai variabel\n        number++;\n    }\n}\n</code></pre> <p>Variabel <code>number</code> hanya berlaku di dalam kurung tempat ia dideklarasikan.</p>"},{"location":"java-basic/04-Variables-and-Scopes/#6-scope-dan-variable-shadowing","title":"6 | Scope dan Variable Shadowing","text":"<p>Bayangkan kita memiliki variabel kelas, dan kita ingin mendeklarasikan variabel metode dengan nama yang sama:</p> <pre><code>public class NestedScopesExample {\n    String title = \"Baeldung\";\n\n    public void printTitle() {\n        System.out.println(title);\n        String title = \"John Doe\";\n        System.out.println(title);\n    }\n}\n</code></pre> <ul> <li>Saat pertama kali mencetak <code>title</code>, akan menampilkan <code>\"Baeldung\"</code>.</li> <li>Setelah itu, kita mendeklarasikan variabel metode dengan nama sama dan memberinya nilai <code>\"John Doe\"</code>.</li> </ul> <p>Variabel metode <code>title</code> ini mengaburkan (shadowing) variabel kelas <code>title</code>. Jadi, saat dicetak kedua kali, akan menampilkan <code>\"John Doe\"</code>.</p> <p>Membingungkan, kan? Ini disebut variable shadowing dan bukan praktik yang baik. Lebih baik menggunakan prefix <code>this</code> untuk mengakses variabel kelas:</p> <pre><code>System.out.println(this.title);\n</code></pre>"},{"location":"java-basic/04-Variables-and-Scopes/#7-kesimpulan","title":"7 |  Kesimpulan","text":"<p>Variabel scope merupakan konsep yang menentukan ruang lingkup serta masa hidup sebuah variabel di dalam program. Dalam Java, ruang lingkup variabel dibedakan menjadi tiga kategori utama, yaitu local variable, instance variable, dan class variable. Local variable hanya berlaku di dalam blok kode tempat variabel tersebut dideklarasikan dan tidak dapat diakses setelah eksekusi keluar dari blok tersebut. Instance variable merupakan bagian dari suatu objek sehingga dapat diakses selama objek tersebut masih berada dalam memori. Sementara itu, class variable yang dideklarasikan dengan kata kunci <code>static</code> menjadi milik kelas dan tetap tersedia sepanjang program berjalan. Variabel berscope kecil akan lebih diutamakan jika terdapat penamaan yang sama dengan variabel berscope lebih besar, dan local variable wajib diinisialisasi sebelum digunakan, tidak seperti instance maupun class variable yang memiliki nilai awal bawaan. Penerapan scope yang tepat berfungsi menjaga keteraturan, mencegah konflik nilai, serta meningkatkan keterbacaan program. Oleh karena itu, variabel sebaiknya dideklarasikan sedekat mungkin dengan lokasi penggunaannya untuk meminimalkan ruang lingkup yang tidak perlu.</p>"},{"location":"java-basic/05-Type-Casting/","title":"Type Casting","text":"<p>Sebelum mempelajari Java Type Casting, pastikan kamu sudah paham tentang Tipe Data di Java.</p>"},{"location":"java-basic/05-Type-Casting/#1-type-casting","title":"1 | Type Casting","text":"<p>Proses mengubah nilai dari satu tipe data (mis. <code>int</code>, <code>float</code>, <code>double</code>, dll.) menjadi tipe data lain disebut typecasting.</p> <p>Di Java, ada 13 jenis konversi tipe data, tetapi pada tutorial ini kita fokus pada dua tipe utama:</p> <ol> <li>Widening Type Casting</li> <li>Narrowing Type Casting</li> </ol> <p>Untuk mempelajari jenis konversi lainnya, lihat dokumentasi resmi Java: Java Type Conversion.</p>"},{"location":"java-basic/05-Type-Casting/#2-widening-type-casting","title":"2 | Widening Type Casting","text":"<p>Pada Widening Type Casting, Java secara otomatis mengonversi satu tipe data ke tipe data lain.</p> <p>Contoh: Mengubah <code>int</code> menjadi <code>double</code></p> <pre><code>class Main {\n  public static void main(String[] args) {\n    // membuat variabel tipe int\n    int num = 10;\n    System.out.println(\"The integer value: \" + num);\n\n    // mengonversi menjadi tipe double\n    double data = num;\n    System.out.println(\"The double value: \" + data);\n  }\n}\n</code></pre> <p>Output:</p> <pre><code>The integer value: 10\nThe double value: 10.0\n</code></pre> <p>Di contoh di atas, variabel <code>num</code> (tipe <code>int</code>) secara otomatis dikonversi menjadi <code>double</code> dan kemudian disimpan di variabel <code>data</code>.</p> <ul> <li>Aturan: tipe data yang lebih kecil (lower data type) dikonversi menjadi tipe data yang lebih besar (higher data type).</li> <li>Tidak ada kehilangan data, sehingga konversi ini terjadi otomatis.</li> <li>Juga dikenal sebagai Implicit Type Casting.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#3-narrowing-type-casting","title":"3 | Narrowing Type Casting","text":"<p>Pada Narrowing Type Casting, kita secara manual mengonversi tipe data menggunakan tanda kurung <code>( )</code>.</p> <p>Contoh: Mengubah <code>double</code> menjadi <code>int</code></p> <pre><code>class Main {\n  public static void main(String[] args) {\n    // membuat variabel tipe double\n    double num = 10.99;\n    System.out.println(\"The double value: \" + num);\n\n    // mengonversi menjadi tipe int\n    int data = (int)num;\n    System.out.println(\"The integer value: \" + data);\n  }\n}\n</code></pre> <p>Output:</p> <pre><code>The double value: 10.99\nThe integer value: 10\n</code></pre> <ul> <li>Baris penting:</li> </ul> <pre><code>int data = (int)num;\n</code></pre> <ul> <li>Tanda <code>(int)</code> menunjukkan bahwa variabel <code>num</code> dikonversi secara eksplisit menjadi tipe <code>int</code>.</li> <li>Aturan: tipe data yang lebih besar (higher data type) dikonversi menjadi tipe data yang lebih kecil (lower data type), sehingga ada kemungkinan kehilangan data.</li> <li>Juga dikenal sebagai Explicit Type Casting.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#4-contoh-konversi-tipe-lain","title":"4 | Contoh konversi tipe lain","text":""},{"location":"java-basic/05-Type-Casting/#41-contoh-1-int-string","title":"4.1 | Contoh 1: <code>int</code> \u2192 <code>String</code>","text":"<pre><code>class Main {\n  public static void main(String[] args) {\n    int num = 10;\n    System.out.println(\"The integer value is: \" + num);\n\n    // konversi int menjadi string\n    String data = String.valueOf(num);\n    System.out.println(\"The string value is: \" + data);\n  }\n}\n</code></pre> <p>Output:</p> <pre><code>The integer value is: 10\nThe string value is: 10\n</code></pre> <ul> <li>Baris penting:</li> </ul> <pre><code>String data = String.valueOf(num);\n</code></pre> <ul> <li>Menggunakan metode <code>valueOf()</code> dari kelas <code>String</code> untuk mengubah <code>int</code> menjadi <code>String</code>.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#42-contoh-2-string-int","title":"4.2 | Contoh 2: <code>String</code> \u2192 <code>int</code>","text":"<pre><code>class Main {\n  public static void main(String[] args) {\n    String data = \"10\";\n    System.out.println(\"The string value is: \" + data);\n\n    // konversi string menjadi int\n    int num = Integer.parseInt(data);\n    System.out.println(\"The integer value is: \" + num);\n  }\n}\n</code></pre> <p>Output:</p> <pre><code>The string value is: 10\nThe integer value is: 10\n</code></pre> <ul> <li>Baris penting:</li> </ul> <pre><code>int num = Integer.parseInt(data);\n</code></pre> <ul> <li>Menggunakan metode <code>parseInt()</code> dari kelas <code>Integer</code> untuk mengubah <code>String</code> menjadi <code>int</code>.</li> </ul> <p>Catatan: Jika string tidak bisa dikonversi menjadi integer, akan muncul NumberFormatException.</p>"},{"location":"java-basic/05-Type-Casting/#5-cheat-sheet-java-type-casting","title":"5 | Cheat-Sheet Java Type Casting","text":"<p>Type Casting adalah proses mengubah nilai dari satu tipe data ke tipe data lain (misal <code>int</code> \u2192 <code>double</code>). Di Java ada dua tipe utama:</p> Jenis Penjelasan Otomatis / Manual Widening (Casting melebar) Tipe kecil \u2192 tipe besar Otomatis (Implicit) Narrowing (Casting menyempit) Tipe besar \u2192 tipe kecil Manual (Explicit) <p>Selain itu, ada konversi lain seperti <code>int \u2192 String</code>, <code>String \u2192 int</code>, dll.</p>"},{"location":"java-basic/05-Type-Casting/#51-widening-type-casting-casting-melebar","title":"5.1 | Widening Type Casting (Casting Melebar)","text":"<ul> <li>Java otomatis mengonversi tipe data kecil menjadi tipe data besar.</li> <li>Tidak ada kehilangan data.</li> <li>Contoh:</li> </ul> <pre><code>int num = 10;      // int\ndouble data = num; // int \u2192 double otomatis\nSystem.out.println(data); // Output: 10.0\n</code></pre> <ul> <li>Aturan: <code>byte \u2192 short \u2192 int \u2192 long \u2192 float \u2192 double</code></li> <li>Alias: Implicit Type Casting</li> </ul> <p>Tips: Gunakan ini untuk operasi matematika atau penyimpanan nilai ke tipe lebih besar tanpa khawatir kehilangan data.</p>"},{"location":"java-basic/05-Type-Casting/#52-narrowing-type-casting-casting-menyempit","title":"5.2 | Narrowing Type Casting (Casting Menyempit)","text":"<ul> <li>Java tidak otomatis, kita harus manual dengan tanda <code>(tipe)</code>.</li> <li>Bisa terjadi kehilangan data.</li> <li>Contoh:</li> </ul> <pre><code>double num = 10.99;\nint data = (int) num; // double \u2192 int manual\nSystem.out.println(data); // Output: 10\n</code></pre> <ul> <li>Aturan: <code>double \u2192 float \u2192 long \u2192 int \u2192 short \u2192 byte</code></li> <li>Alias: Explicit Type Casting</li> </ul> <p>Tips: Selalu sadar akan kemungkinan kehilangan data saat casting tipe besar \u2192 kecil.</p>"},{"location":"java-basic/05-Type-Casting/#6-contoh-konversi-lain-diperluas","title":"6 | Contoh Konversi Lain Diperluas","text":""},{"location":"java-basic/05-Type-Casting/#61-int-string","title":"6.1 | <code>int</code> \u2192 <code>String</code>","text":"<pre><code>int num = 10;\nString str = String.valueOf(num);\nSystem.out.println(str); // Output: \"10\"\n</code></pre> <ul> <li>Gunakan <code>String.valueOf()</code> untuk mengubah tipe primitif menjadi String.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#62-string-int","title":"6.2 | <code>String</code> \u2192 <code>int</code>","text":"<pre><code>String str = \"10\";\nint num = Integer.parseInt(str);\nSystem.out.println(num); // Output: 10\n</code></pre> <ul> <li>Gunakan <code>Integer.parseInt()</code>.</li> <li>Catatan: Jika string tidak bisa dikonversi \u2192 muncul <code>NumberFormatException</code>.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#63-int-char","title":"6.3 | <code>int</code> \u2192 <code>char</code>","text":"<pre><code>int code = 65;\nchar letter = (char) code;\nSystem.out.println(letter); // Output: 'A'\n</code></pre>"},{"location":"java-basic/05-Type-Casting/#64-long-int","title":"6.4 | <code>long</code> \u2192 <code>int</code>","text":"<pre><code>long big = 100L;\nint smaller = (int) big;\nSystem.out.println(smaller); // Output: 100\n</code></pre> <ul> <li>Waspadai overflow jika nilai <code>long</code> terlalu besar untuk <code>int</code>.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#65-double-int","title":"6.5 | <code>double</code> \u2192 <code>int</code>","text":"<pre><code>double pi = 3.14;\nint whole = (int) pi;\nSystem.out.println(whole); // Output: 3\n</code></pre> <ul> <li>Nilai di belakang koma akan hilang.</li> </ul>"},{"location":"java-basic/05-Type-Casting/#7-ringkasan-implicit-vs-explicit","title":"7 | Ringkasan Implicit vs Explicit","text":"Tipe Casting Contoh Otomatis? Risiko Hilangnya Data? Widening <code>int \u2192 double</code> Ya Tidak Narrowing <code>double \u2192 int</code> Tidak Ya int \u2192 String <code>String.valueOf(int)</code> Manual Tidak String \u2192 int <code>Integer.parseInt(String)</code> Manual Bisa Exception int \u2192 char <code>(char) int</code> Manual Bisa karakter berbeda long \u2192 int <code>(int) long</code> Manual Bisa overflow"},{"location":"java-basic/05-Type-Casting/#8-tips-praktis","title":"8 | Tips Praktis","text":"<ol> <li>Gunakan Widening jika memungkinkan \u2192 aman dan otomatis.</li> <li>Gunakan Narrowing dengan hati-hati \u2192 cek kehilangan data.</li> <li>String \u2194 int hanya untuk input/output atau parsing.</li> <li>Casting numerik \u2192 char hanya untuk karakter Unicode / ASCII.</li> <li>Hindari casting yang tidak perlu \u2192 bikin kode lebih bersih dan aman.</li> </ol>"},{"location":"java-basic/06-Strings-and-Methods/","title":"Java String","text":"<p>Tipe data String dalam Java dapat berisi serangkaian karakter (string), seperti mutiara pada sutas tali. String adalah cara Anda bekerja dengan teks di Java. Setelah String dalam Java dibuat, Anda dapat mencari di dalamnya, membuat substring darinya, membuat string baru berdasarkan string pertama dengan beberapa bagian yang dignati, dan banyak hal lainya.</p>"},{"location":"java-basic/06-Strings-and-Methods/#1-representasi-string-internal","title":"1 | Representasi String Internal","text":"<p>String Java (sebelum Java 9) direpresentasikan secara internal di JVM menggunakan byte, yang dikodekan sebagai UTF-16. UTF-16 menggunakan 2 byte untuk merepresentasikan satu karakter. Dengan demikian, karakter-karakter dalam String Java direpresentasikan menggunakan <code>char</code> array.</p> <p>UTF adalah pengkodena karakter yang dapat merepresentasikan karakter dari berbagai bahasa (alfabet). Oleh karena itu, diperlukan 2 byte per karakter agar semua karakter yang berbeda ini dapat direpresentasikan dalam satu String.</p>"},{"location":"java-basic/06-Strings-and-Methods/#11-compact-string","title":"1.1 | Compact String","text":"<p>Mulai Java 9 dan seterusnya, JVM dapat mengoptimalkan string menggunakan fitur Java baru yang disebut compact strings. Fitur compact strings memungkinkan Java VM mendeteksi apakah suatu string hanya berisi karakter ISO-8859-1/Latin-1. Jika ya, String hanya akan menggunakan 1 byte per karakter secara internal. Dengan demikian, karakter dari String Java yang ringkas dapat direpresentasikan oleh <code>byte</code> array, bukan <code>char</code> array.</p> <p>Keterwakilan sebuah String sebagai compact string akan terdeteksi saat string tersebut dibuat. String tidak dapat diubah setelah dibuat - jadi hal ini aman untuk dilakukan.</p>"},{"location":"java-basic/06-Strings-and-Methods/#2-membuat-string","title":"2 | Membuat String","text":"<p>String dalam Java adalah objek. Oleh karena itu, Anda perlu menggunakan operator <code>new</code> untuk membuat objek String Java baru. Berikut adalah contoh pembuatan (instansiasi) String Java:</p> <pre><code>String myString = new String(\"Halo Dunia\");\n</code></pre> <p>Teks di dalam tanda kutip adalah teks yang akan dimuat dalam objek String.</p>"},{"location":"java-basic/06-Strings-and-Methods/#21-literal-string-java","title":"2.1 | Literal String Java","text":"<p>Java memiliki cara yang lebih singkat untuk membuat String baru:</p> <pre><code>String myString = \"Halo Dunia\";\n</code></pre> <p>Alih-alih meneruskan teks \"Hello World\" sebagai parameter ke konstruktor String, Anda cukup menuliskan teks itu sendiri di dalam tanda kutip ganda. Ini disebut literal String. Kompiler Java akan secara internal mencari cara untuk membuat String Java baru yang mewakili teks yang diberikan.</p>"},{"location":"java-basic/06-Strings-and-Methods/#22-escape-karakter","title":"2.2 | Escape Karakter","text":"<p>Literal String Java menerima serangkaian karakter escape yang diterjemahkan menjadi karakter khusus dalam String yang dibuat. Karakter escape ini meliputi:</p> Esc. Karakter Keterangan <code>\\\\</code> Diterjemahkan menjadi karakter tunggal backslash <code>\\</code> dalam String <code>\\t</code> Diterjemahkan menjadi karakter tab tunggal dalam string <code>\\r</code> Diterjemahkan menjadi karakter carriege return dalam String <code>\\n</code> Diterjemahkan menjadi karakter baris baru tunggal dalam String <p>Berikut adalah contoh pembuatan String Java menggunakan karakter escape:</p> <pre><code>String teks = \"\\tTeks ini ada di satu tab.\\r\\n\";\n</code></pre> <p>Literal String ini akan menghasilkan String yang dimulai dengan karakter tab dan diakhiri dengan carriage return dan karakter baris baru.</p>"},{"location":"java-basic/06-Strings-and-Methods/#23-string-literals-sebagai-konstanta-atau-singleton","title":"2.3 |  String Literals sebagai Konstanta atau Singleton","text":"<p>Jika kamu menggunakan string yang sama (misal <code>\"Hello World\"</code>) di deklarasi variabel String lain, Java Virtual Machine (JVM) mungkin hanya akan membuat satu instance String di memori. Dengan demikian, literal string tersebut secara praktis menjadi konstanta atau singleton. Berbagai variabel yang diinisialisasi dengan string konstanta yang sama akan menunjuk ke instance String yang sama di memori.</p> <p>Contoh:</p> <pre><code>String myString1 = \"Hello World\";\nString myString2 = \"Hello World\";\n</code></pre> <p>Dalam kasus ini, JVM akan membuat <code>myString1</code> dan <code>myString2</code> menunjuk ke objek String yang sama.</p> <p>Lebih tepatnya, objek yang mewakili literal String Java diperoleh dari constant String pool yang disimpan secara internal oleh JVM. Artinya, bahkan kelas dari proyek berbeda yang dikompilasi secara terpisah, tetapi digunakan di aplikasi yang sama, dapat berbagi objek String konstanta. Proses berbagi ini terjadi pada saat runtime, bukan saat compile time.</p> <p>Jika kamu ingin memastikan bahwa dua variabel String menunjuk ke objek String yang berbeda, gunakan operator <code>new</code>:</p> <pre><code>String myString1 = new String(\"Hello World\");\nString myString2 = new String(\"Hello World\");\n</code></pre> <p>Meskipun nilai (teks) kedua String sama, JVM akan membuat dua objek berbeda di memori untuk mewakili keduanya.</p>"},{"location":"java-basic/06-Strings-and-Methods/#24-java-text-blocks","title":"2.4 |  Java Text Blocks","text":"<p>Java text blocks, atau dikenal juga sebagai Java multi-line strings, adalah fitur yang ditambahkan di Java 13 (saat preview) yang memudahkan kita untuk mendeklarasikan literal String yang membentang ke beberapa baris dalam kode Java.</p> <p>Contoh sintaks Java text block:</p> <pre><code>String textblock = \"\"\"\n                   This is a text inside a\n                   text block\n                   \"\"\";\n</code></pre> <p>Perhatikan dua set delimiter (<code>\"\"\"</code>) di baris pertama dan terakhir. Tiga karakter kutip berturut-turut ini memberitahu Java compiler bahwa yang sedang dideklarasikan adalah text block.</p> <ul> <li>Kedua set karakter kutip harus berada di baris sendiri, di atas dan di bawah teks yang ingin dimasukkan ke text block.</li> <li>Hanya teks di antara baris dengan delimiter yang akan menjadi bagian dari hasil String Java.</li> </ul> <p>Di antara delimiter, kamu bisa menulis multi-line String tanpa perlu melakukan escape untuk newline atau karakter kutip.</p> <p>Contoh penggunaan kutip di dalam text block:</p> <pre><code>String textblock = \"\"\"\n                   This is a text inside a\n                   text block.\n                   You can use \"quotes\" in here\n                   without escaping them.\n                   \"\"\";\n</code></pre> <p>Perhatikan kutip di sekitar kata <code>\"quotes\"</code>.</p> <ul> <li>Di literal String Java biasa, kamu harus melakukan escape untuk kutip ini.</li> <li>Di text block, escape tidak diperlukan, kecuali jika kamu ingin menyertakan tiga kutip berturut-turut (<code>\"\"\"</code>) sebagai bagian dari teks.</li> <li>Dalam kasus itu, kamu harus melakukan escape setidaknya satu kutip supaya compiler dapat membedakannya dari delimiter akhir text block.</li> </ul>"},{"location":"java-basic/06-Strings-and-Methods/#25-indentasi-pada-java-text-block","title":"2.5 | Indentasi pada Java Text Block","text":"<p>Pada contoh Java text block sebelumnya, teks di antara dua baris dengan tiga delimiter kutip (<code>\"\"\"</code>) diindentasikan agar posisinya sejajar secara horizontal dengan delimiter. Dengan kata lain, teks dimulai di posisi horizontal yang sama dengan delimiter. Hal ini dilakukan semata-mata untuk alasan formatting kode. Biasanya, kita tidak ingin semua karakter indentasi (spasi atau tab) menjadi bagian dari String yang sebenarnya dihasilkan dari text block ini.</p> <p>Yang terjadi sebenarnya adalah Java compiler menghapus semua karakter indentasi dari String yang dihasilkan oleh deklarasi text block. Cara compiler menentukan berapa banyak karakter indentasi yang dihapus adalah dengan melihat baris terakhir dari text block, yaitu baris yang berisi tiga karakter kutip terakhir. Indentasi dari karakter kutip pada baris terakhir ini menentukan berapa banyak karakter indentasi yang dihapus dari teks di dalam text block.</p> <p>Berikut contoh tiga Java text block dengan tingkat indentasi berbeda, dikontrol oleh posisi delimiter kutip terakhir:</p> <pre><code>String textblock1 = \"\"\"\n                   This is a Java text block\n                   \"\"\";\n\nString textblock2 = \"\"\"\n                   This is a Java text block\n                 \"\"\";\n\nString textblock3 = \"\"\"\n                   This is a Java text block\n               \"\"\";\n\nSystem.out.println(textblock1);\nSystem.out.println(textblock2);\nSystem.out.println(textblock3);\n</code></pre> <p>Perhatikan perbedaan posisi delimiter kutip terakhir:</p> <ul> <li>Pada contoh pertama, delimiter kutip terakhir berada sejajar dengan teks, sehingga semua karakter indentasi dihapus dari String.</li> <li>Pada contoh kedua, delimiter kutip terakhir berada 2 karakter lebih ke kiri dibanding teks. Akibatnya, compiler menyisakan 2 karakter indentasi di String yang dihasilkan.</li> <li>Pada contoh ketiga, delimiter kutip terakhir berada 4 karakter lebih ke kiri dibanding teks, sehingga 4 karakter indentasi disertakan di String.</li> </ul> <p>Output yang dihasilkan:</p> <pre><code>This is a Java text block\n\n  This is a Java text block\n\n    This is a Java text block\n</code></pre> <p>Seperti terlihat, String yang dihasilkan memiliki tingkat indentasi yang berbeda.</p> <p>Intinya, perbedaan posisi horizontal karakter delimiter terakhir dan karakter paling kiri teks di text block menentukan seberapa banyak indentasi yang disertakan dalam String yang dihasilkan. Java compiler menggunakan perbandingan ini untuk menentukan indentasi yang harus dimasukkan.</p>"},{"location":"java-basic/06-Strings-and-Methods/#3-menggabungkan-string","title":"3 | Menggabungkan String","text":"<p>Menggabungkan String berarti menambahkan satu string ke string lainnya. String dalam Java bersifat immutable, yang berarti nilai di dalamnya tidak dapat diubah setelah objek tersebut dibuat. Oleh karena itu, ketika dua objek String digabungkan, hasil penggabungannya sebenarnya disimpan pada objek String baru yang ketiga.</p> <p>Berikut contoh penggabungan String dalam Java:</p> <pre><code>String one = \"Hello\";\nString two = \"World\";\n\nString three = one + \" \" + two;\n</code></pre> <p>Isi String yang direferensikan oleh variabel <code>three</code> adalah <code>Hello World</code>. Sementara itu, kedua objek String lainnya tidak mengalami perubahan.</p>"},{"location":"java-basic/06-Strings-and-Methods/#31-kinerja-penggabungan-string","title":"3.1 | Kinerja Penggabungan String","text":"<p>Saat menggabungkan String, Anda perlu mewaspadai potensi masalah kinerja. Penggabungan dua String di Java akan diterjemahkan oleh compiler Java menjadi sesuatu seperti berikut:</p> <pre><code>String one = \"Hello\";\nString two = \" World\";\n\nString three = new StringBuilder(one)\n                    .append(two).toString();\n</code></pre> <p>Seperti terlihat, sebuah objek <code>StringBuilder</code> baru dibuat, dengan String pertama diteruskan ke konstrukturnya, dan String kedua ditambahkan melalui metode <code>append()</code>, sebelum akhirnya memanggil metode <code>toString()</code>. Kode ini sebenarnya membuat dua objek: sebuah instance <code>StringBuilder</code> dan sebuah objek String baru yang dikembalikan oleh <code>toString()</code>.</p> <p>Jika dijalankan sebagai satu pernyataan tunggal, beban pembuatan objek tambahan ini tidak terlalu signifikan. Namun, bila digunakan di dalam sebuah loop, situasinya berubah.</p> <p>Berikut contoh loop yang memuat pola penggabungan String seperti di atas:</p> <pre><code>String[] strings = \n  new String[]{\"one\", \"two\", \"three\", \"four\", \"five\"};\n\nString result = null;\nfor(String string : strings) {\n    result = result + string;\n}\n</code></pre> <p>Kode ini akan dikompilasi menjadi sesuatu yang kurang lebih seperti:</p> <pre><code>String[] strings = \n  new String[]{\"one\", \"two\", \"three\", \"four\", \"five\"};\n\nString result = null;\nfor(String string : strings) {\n    result = new StringBuilder(result)\n                    .append(string).toString();\n}\n</code></pre> <p>Pada setiap iterasi dalam loop tersebut, sebuah objek <code>StringBuilder</code> baru dibuat. Selain itu, sebuah objek String juga dibuat melalui pemanggilan metode <code>toString()</code>. Hal ini menghasilkan sedikit beban pembuatan objek pada setiap iterasi: satu objek <code>StringBuilder</code> dan satu objek <code>String</code>. Namun, beban ini bukanlah penyebab utama menurunnya kinerja. Masalah sebenarnya muncul dari proses yang terjadi selama pembuatan objek-objek tersebut.</p> <p>Setiap kali kode <code>new StringBuilder(result)</code> dieksekusi, konstruktor <code>StringBuilder</code> menyalin seluruh karakter dari String <code>result</code> ke dalam <code>StringBuilder</code>. Semakin banyak iterasi yang dijalankan, semakin panjang String <code>result</code>. Semakin panjang String tersebut, semakin lama waktu yang dibutuhkan untuk menyalin karakter ke <code>StringBuilder</code>, dan kemudian menyalin kembali karakter-karakter tersebut ke String sementara yang dihasilkan oleh <code>toString()</code>. Dengan kata lain, semakin banyak iterasi, semakin lambat setiap iterasinya.</p> <p>Cara tercepat untuk menggabungkan String adalah dengan membuat satu <code>StringBuilder</code> saja, lalu menggunakannya kembali di dalam loop. Contohnya sebagai berikut:</p> <pre><code>String[] strings = \n  new String[]{\"one\", \"two\", \"three\", \"four\", \"five\"};\n\nStringBuilder temp  = new StringBuilder();\nfor(String string : strings) {\n    temp.append(string);\n}\nString result = temp.toString();\n</code></pre> <p>Kode ini menghindari pembuatan objek <code>StringBuilder</code> dan objek String di dalam loop, sehingga juga menghindari proses penyalinan karakter dua kali\u2014pertama ke dalam <code>StringBuilder</code>, dan kemudian kembali ke String baru.</p>"},{"location":"java-basic/06-Strings-and-Methods/#4-panjang-string","title":"4 | Panjang String","text":"<p>Anda dapat memperoleh panjang sebuah String dengan menggunakan metode <code>length()</code>. Panjang sebuah String adalah jumlah karakter yang dikandung oleh String tersebut\u2014bukan jumlah byte yang digunakan untuk merepresentasikannya. Berikut contohnya:</p> <pre><code>String string = \"Hello World\";\nint length = string.length();\n</code></pre>"},{"location":"java-basic/06-Strings-and-Methods/#5-substrings","title":"5 | Substrings","text":"<p>Anda dapat mengambil sebagian dari sebuah String. Proses ini disebut substring. Untuk melakukannya, Anda menggunakan metode <code>substring()</code> milik kelas <code>String</code>. Berikut contohnya:</p> <pre><code>String string1 = \"Hello World\";\n\nString substring = string1.substring(0,5);\n</code></pre> <p>Setelah kode tersebut dijalankan, variabel <code>substring</code> akan berisi teks <code>Hello</code>.</p> <p>Metode <code>substring()</code> menerima dua parameter. Parameter pertama adalah indeks karakter pertama yang akan disertakan dalam substring. Parameter kedua adalah indeks karakter setelah karakter terakhir yang akan disertakan. Perhatikan baik-baik: parameternya berarti \u201cdari \u2013 termasuk, sampai \u2013 tidak termasuk\u201d. Pola ini mungkin terlihat membingungkan sampai Anda terbiasa.</p> <p>Karakter pertama dalam sebuah String memiliki indeks 0, karakter kedua memiliki indeks 1, dan seterusnya. Karakter terakhir memiliki indeks <code>String.length() - 1</code>.</p>"},{"location":"java-basic/06-Strings-and-Methods/#6-mencari-dalam-string-dengan-indexof","title":"6 | Mencari dalam String dengan <code>indexOf()</code>","text":"<p>Anda dapat mencari substring di dalam sebuah String dengan menggunakan metode <code>indexOf()</code>. Contohnya sebagai berikut:</p> <pre><code>String string1 = \"Hello World\";\n\nint index = string1.indexOf(\"World\");\n</code></pre> <p>Setelah kode tersebut dijalankan, variabel <code>index</code> akan bernilai 6. Metode <code>indexOf()</code> mengembalikan indeks karakter pertama dari substring yang cocok. Dalam contoh ini, huruf W pada kata World ditemukan pada indeks 6.</p> <p>Jika substring yang dicari tidak ditemukan di dalam String, metode <code>indexOf()</code> akan mengembalikan nilai <code>-1</code>.</p> <p>Terdapat juga versi lain dari metode <code>indexOf()</code> yang menerima parameter tambahan berupa indeks awal pencarian. Dengan cara ini, Anda dapat mencari lebih dari satu kemunculan substring dalam sebuah String. Contohnya:</p> <pre><code>String theString = \"is this good or is this bad?\";\nString substring = \"is\";\n\nint index = theString.indexOf(substring);\nwhile(index != -1) {\n    System.out.println(index);\n    index = theString.indexOf(substring, index + 1);\n}\n</code></pre> <p>Kode tersebut akan mencetak semua posisi di mana substring <code>\"is\"</code> ditemukan.</p> <p>Kode tersebut melakukan pencarian di dalam string <code>\"is this good or is this bad?\"</code> untuk menemukan semua kemunculan substring <code>\"is\"</code>. Pencarian dilakukan menggunakan metode <code>indexOf(substring, index)</code>. Parameter <code>index</code> menentukan dari posisi karakter mana pencarian harus dimulai. Pada contoh ini, pencarian dimulai dari satu karakter setelah posisi kemunculan sebelumnya. Hal ini memastikan bahwa pencarian tidak terus-menerus menemukan kemunculan yang sama.</p> <p>Keluaran yang dihasilkan dari kode tersebut adalah:</p> <pre><code>0\n5\n16\n21\n</code></pre> <p>Substring <code>\"is\"</code> ditemukan sebanyak empat kali: dua kali sebagai kata tersendiri <code>\"is\"</code>, dan dua kali sebagai bagian dari kata <code>\"this\"</code>.</p> <p>Kelas <code>String</code> dalam Java juga menyediakan metode <code>lastIndexOf()</code> yang digunakan untuk menemukan kemunculan terakhir dari sebuah substring. Contohnya:</p> <pre><code>String theString = \"is this good or is this bad?\";\nString substring = \"is\";\n\nint index = theString.lastIndexOf(substring);\nSystem.out.println(index);\n</code></pre> <p>Keluaran dari kode tersebut adalah <code>21</code>, yaitu indeks kemunculan terakhir dari substring <code>\"is\"</code>.</p>"},{"location":"java-basic/06-Strings-and-Methods/#7-mencocokkan-string-dengan-ekspresi-reguler-dengan-matches","title":"7 | Mencocokkan String dengan Ekspresi Reguler dengan <code>matches()</code>","text":"<p>Metode <code>matches()</code> pada kelas <code>String</code> menerima sebuah regular expression sebagai parameter, dan mengembalikan nilai <code>true</code> jika regular expression tersebut cocok dengan isi string, serta <code>false</code> jika tidak cocok.</p> <p>Berikut contoh penggunaan <code>matches()</code>:</p>"},{"location":"java-basic/06-Strings-and-Methods/#string-text-one-two-three-two-one-boolean-matches-textmatchestwo","title":"<pre><code>String text = \"one two three two one\";\n\nboolean matches = text.matches(\".*two.*\");\n</code></pre>","text":""},{"location":"java-basic/06-Strings-and-Methods/#8-comparing-strings","title":"8 | Comparing Strings","text":"<p>Kelas <code>String</code> dalam Java menyediakan sejumlah metode untuk membandingkan String. Metode-metode tersebut antara lain:</p> <ul> <li><code>equals()</code></li> <li><code>equalsIgnoreCase()</code></li> <li><code>startsWith()</code></li> <li><code>endsWith()</code></li> <li><code>compareTo()</code></li> </ul>"},{"location":"java-basic/06-Strings-and-Methods/#81-equals","title":"8.1 | equals()","text":"<p>Metode <code>equals()</code> digunakan untuk memeriksa apakah dua String benar-benar identik. Jika keduanya sama persis, <code>equals()</code> mengembalikan <code>true</code>. Jika tidak sama, metode ini mengembalikan <code>false</code>. Berikut contohnya:</p> <pre><code>String one   = \"abc\";\nString two   = \"def\";\nString three = \"abc\";\nString four  = \"ABC\";\n\nSystem.out.println( one.equals(two) );\nSystem.out.println( one.equals(three) );\nSystem.out.println( one.equals(four) );\n</code></pre> <p>String <code>one</code> dan <code>three</code> bernilai sama, tetapi <code>one</code> tidak sama dengan <code>two</code> maupun <code>four</code>. Perlu diperhatikan bahwa perbandingan ini bersifat case-sensitive\u2014huruf kecil dianggap berbeda dari huruf besar.</p> <p>Keluaran dari kode tersebut adalah:</p> <pre><code>false\ntrue\nfalse\n</code></pre>"},{"location":"java-basic/06-Strings-and-Methods/#82-equalsignorecase","title":"8.2 | equalsIgnoreCase()","text":"<p>Kelas <code>String</code> juga memiliki metode <code>equalsIgnoreCase()</code> yang membandingkan dua String tanpa memperhatikan perbedaan huruf besar dan huruf kecil. Dengan demikian, huruf kapital dianggap sama dengan huruf kecil yang bersesuaian.</p>"},{"location":"java-basic/06-Strings-and-Methods/#83-startswith-dan-endswith","title":"8.3 | startsWith() dan endsWith()","text":"<p>Metode <code>startsWith()</code> dan <code>endsWith()</code> digunakan untuk memeriksa apakah sebuah String diawali atau diakhiri dengan substring tertentu. Berikut contohnya:</p> <pre><code>String one = \"This is a good day to code\";\n\nSystem.out.println( one.startsWith(\"This\")    );\nSystem.out.println( one.startsWith(\"This\", 5) );\n\nSystem.out.println( one.endsWith  (\"code\")    );\nSystem.out.println( one.endsWith  (\"shower\")  );\n</code></pre> <p>Contoh ini membuat sebuah String dan memeriksa apakah String tersebut diawali atau diakhiri oleh beberapa substring.</p> <ul> <li> <p>Baris pertama (setelah deklarasi String) memeriksa apakah String diawali oleh <code>\"This\"</code>. Karena cocok, metode <code>startsWith()</code> mengembalikan <code>true</code>.</p> </li> <li> <p>Baris kedua memeriksa apakah String diawali oleh <code>\"This\"</code> jika pemeriksaan dimulai dari karakter pada indeks 5. Hasilnya <code>false</code>, karena karakter pada indeks 5 adalah <code>\"i\"</code>.</p> </li> <li> <p>Baris ketiga memeriksa apakah String diakhiri dengan <code>\"code\"</code>. Karena sesuai, metode <code>endsWith()</code> mengembalikan <code>true</code>.</p> </li> <li> <p>Baris keempat memeriksa apakah String diakhiri dengan <code>\"shower\"</code>. Karena tidak sesuai, hasilnya <code>false</code>.</p> </li> </ul>"},{"location":"java-basic/06-Strings-and-Methods/#84-compareto","title":"8.4 | compareTo()","text":"<p>Metode <code>compareTo()</code> membandingkan sebuah String dengan String lain dan mengembalikan nilai bertipe <code>int</code> yang menunjukkan apakah String tersebut lebih kecil, sama, atau lebih besar dibandingkan String yang menjadi pembanding.</p> <ul> <li>Jika String berada sebelum String pembanding dalam urutan penyortiran, <code>compareTo()</code> mengembalikan nilai negatif.</li> <li>Jika keduanya berada pada posisi penyortiran yang sama, metode ini mengembalikan <code>0</code>.</li> <li>Jika String berada setelah String pembanding dalam urutan penyortiran, metode ini mengembalikan nilai positif.</li> </ul> <p>Contohnya:</p> <pre><code>String one   = \"abc\";\nString two   = \"def\";\nString three = \"abd\";\n\nSystem.out.println( one.compareTo(two)   );\nSystem.out.println( one.compareTo(three) );\n</code></pre> <p>Contoh ini membandingkan String <code>one</code> dengan dua String lainnya. Keluaran dari kode tersebut adalah:</p> <pre><code>-3\n-1\n</code></pre> <p>Nilai negatif muncul karena String <code>one</code> berada lebih awal dalam urutan penyortiran dibandingkan kedua String lainnya.</p> <p>Metode <code>compareTo()</code> sebenarnya berasal dari antarmuka <code>Comparable</code>, yang dibahas lebih mendalam dalam materi tentang penyortiran.</p> <p>Perlu diperhatikan bahwa <code>compareTo()</code> tidak selalu menghasilkan hasil yang benar untuk String dalam bahasa selain bahasa Inggris. Untuk melakukan penyortiran String secara benar dalam bahasa tertentu, gunakan kelas <code>Collator</code>.</p>"},{"location":"java-basic/07-Math-Operations/","title":"Math Operation","text":""},{"location":"java-basic/08-Arrays/","title":"Arrays","text":""},{"location":"java-basic/09-Conditionals/","title":"Conditionals","text":""},{"location":"java-basic/10-Loops/","title":"Loops","text":""},{"location":"java-basic/11-Basics-of-OOP/","title":"Basic of OOp","text":""}]}